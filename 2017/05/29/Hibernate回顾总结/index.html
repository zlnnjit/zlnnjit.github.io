<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#2020'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>Hibernate回顾总结 - zln&#39;s blog</title>
  
    <meta name="keywords" content="J2EE,SSH,ORM,Hibernate,jdbc">
  
  
    <meta name="description" content="Hibernate概述
Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web...">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css">
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div class="cover-wrapper">
    
      <cover class='cover post half'>
        <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">bcoder.top</p>
    
    
      <p class="subtitle">不忘初心，无畏前行</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="" />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <ul class='h-list'>
        
          
            <li>
              <a class="nav home"
                href="/"
                
                
                id="home">
                <i class='fas fa-rss fa-fw'></i>&nbsp;博客
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/categories/"
                
                
                id="categories">
                <i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/tags/"
                
                
                id="tags">
                <i class='fas fa-tags fa-fw'></i>&nbsp;标签
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/archives/"
                
                
                id="archives">
                <i class='fas fa-archive fa-fw'></i>&nbsp;归档
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="https://github.com/zlnnjit"
                
                
                  target="_blank"
                
                id="https:githubcomzlnnjit">
                <i class='fas fa-link fa-fw'></i>&nbsp;github
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/about/"
                
                
                id="about">
                <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
              </a>
            </li>
          
        
      </ul>
    </div>
  </div>
</div>

      </cover>
    
    <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">

  <div class='wrapper'>
    <div class='nav-sub container--flex'>
      <a class="logo flat-box"></a>
      <ul class='switcher h-list'>
        <li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main container container--flex">
      
        
        <a class="logo flat-box" target="_self" href='/'>
          
          
          
          
            周陆宁 <b><sup style='color:#3AA757'>2020</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='h-list'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  
                    <i class='fas fa-rss fa-fw'></i>
                  
                  博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  
                    <i class='fas fa-folder-open fa-fw'></i>
                  
                  分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  
                    <i class='fas fa-tags fa-fw'></i>
                  
                  标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  
                    <i class='fas fa-archive fa-fw'></i>
                  
                  归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=https://github.com/zlnnjit
                  
                  
                    target="_blank"
                  
                  
                    id="https:githubcomzlnnjit"
                  >
                  
                    <i class='fas fa-link fa-fw'></i>
                  
                  github
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  
                    <i class='fas fa-info-circle fa-fw'></i>
                  
                  关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      
        <div class="m_search">
          <form name="searchform" class="form u-search-form">
            <i class="icon fas fa-search fa-fw"></i>
            <input type="text" class="input u-search-input" placeholder="搜索" />
          </form>
        </div>
      

			<ul class='switcher h-list'>
				
					<li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a></li>
			</ul>
		</div>
	</div>
</header>
<ul class="menu-phone navigation white-box">
  
  
    <li>
      <a class="flat-box" href=/
        
        
        
          id="home"
        >
        
          <i class='fas fa-rss fa-fw'></i>
        
        博客
      </a>
    </li>
  
    <li>
      <a class="flat-box" href=/categories/
        
        
        
          id="categories"
        >
        
          <i class='fas fa-folder-open fa-fw'></i>
        
        分类
      </a>
    </li>
  
    <li>
      <a class="flat-box" href=/tags/
        
        
        
          id="tags"
        >
        
          <i class='fas fa-tags fa-fw'></i>
        
        标签
      </a>
    </li>
  
    <li>
      <a class="flat-box" href=/archives/
        
        
        
          id="archives"
        >
        
          <i class='fas fa-archive fa-fw'></i>
        
        归档
      </a>
    </li>
  
    <li>
      <a class="flat-box" href=/friends/
        
        
        
          id="friends"
        >
        
          <i class='fas fa-link fa-fw'></i>
        
        友链
      </a>
    </li>
  
    <li>
      <a class="flat-box" href=/about/
        
        
        
          id="about"
        >
        
          <i class='fas fa-info-circle fa-fw'></i>
        
        关于
      </a>
    </li>
  
</ul>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2017/05/29/Hibernate%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/">
        Hibernate回顾总结
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
<div class='new-meta-item author'>
  <a href="" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>周陆宁</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/Hibernate/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Hibernate</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2017-05-29 09:22:05</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>字数：25.7k</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>时长：104 分钟</p>
    </a>
  </div>


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h2 id="Hibernate概述"><a href="#Hibernate概述" class="headerlink" title="Hibernate概述"></a>Hibernate概述</h2><ul>
<li>Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。 Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架</li>
</ul>
<a id="more"></a>

<h3 id="什么是ORM（对象关系映射）"><a href="#什么是ORM（对象关系映射）" class="headerlink" title="什么是ORM（对象关系映射）"></a>什么是ORM（对象关系映射）</h3><p>ORM映射：Object Relational Mapping</p>
<ul>
<li>O：面向对象领域的Object（JavaBean对象）</li>
<li>R：关系数据库领域的Relational（表的结构）</li>
<li>M：映射Mapping（XML的配置文件）</li>
</ul>
<p>简单一句话：Hibernate使程序员通过操作对象的方式来操作数据库表记录</p>
<h3 id="Hibernate优点"><a href="#Hibernate优点" class="headerlink" title="Hibernate优点"></a>Hibernate优点</h3><ul>
<li>Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码</li>
<li>Hibernate是一个基于jdbc的主流持久化框架，是一个优秀的orm实现，它很大程度的简化了dao层编码工作</li>
<li>Hibernate的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系</li>
</ul>
<h3 id="Hibernate知识体系"><a href="#Hibernate知识体系" class="headerlink" title="Hibernate知识体系"></a>Hibernate知识体系</h3><p><img src="http://img.bcoder.top/2017.05.29/1.png" alt="11"></p>
<h3 id="Hibernate架构图"><a href="#Hibernate架构图" class="headerlink" title="Hibernate架构图"></a>Hibernate架构图</h3><p><img src="http://img.bcoder.top/2017.05.29/2.jpg" alt=""></p>
<p>Hibernate 架构是分层的，作为数据访问层，你不必知道底层 API 。Hibernate 利用数据库以及配置数据来为应用程序提供持续性服务（以及持续性对象）。<br>下面是一个非常高水平的 Hibernate 应用程序架构视图。</p>
<p><img src="http://img.bcoder.top/2017.05.29/3.jpg" alt=""></p>
<p>下面是一个详细的 Hibernate 应用程序体系结构视图以及一些重要的类。</p>
<p><img src="http://img.bcoder.top/2017.05.29/4.jpg" alt=""></p>
<p>Hibernate 使用不同的现存 Java API，比如 JDBC，Java 事务 API（JTA），以及 Java 命名和目录界面（JNDI）。JDBC 提供了一个基本的抽象级别的通用关系数据库的功能， Hibernate 支持几乎所有带有 JDBC 驱动的数据库。JNDI 和 JTA 允许 Hibernate 与 J2EE 应用程序服务器相集成。</p>
<h2 id="Hibernate-入门程序"><a href="#Hibernate-入门程序" class="headerlink" title="Hibernate 入门程序"></a>Hibernate 入门程序</h2><p><strong>第一步：下载Hibernate5的运行环境</strong></p>
<pre><code>1. 下载相应的jar包等
    * http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/hibernate-release-5.0.7.Final.zip/download    

2. 解压后对目录结构有一定的了解

3.不要忘记下载相应数据库驱动包 </code></pre><hr>
<p><strong>第二步：创建表结构</strong></p>
<ol>
<li>建表语句如下<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键id'</span>,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">age <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">sex <span class="built_in">VARCHAR</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line">city <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'城市'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>第三步：搭建Hibernate的开发环境</strong></p>
<pre><code>1. 创建WEB工程，引入Hibernate开发所需要的jar包
    * MySQL的驱动jar包
    * Hibernate开发需要的jar包（资料/hibernate-release-5.0.7.Final/lib/required/所有jar包）
    * 日志jar包）（可选）</code></pre><hr>
<p><strong>第四步：编写JavaBean实体类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.bcoder.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String sex;</span><br><span class="line">	<span class="keyword">private</span> String city;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.sex = sex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> city;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.city = city;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Customer [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", sex="</span> + sex + <span class="string">", city="</span> + city + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Integer id, String name, <span class="keyword">int</span> age, String sex, String city)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.sex = sex;</span><br><span class="line">		<span class="keyword">this</span>.city = city;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>第五步：创建类与表结构的映射</strong></p>
<ol>
<li><p>在JavaBean所在的包下创建映射的配置文件</p>
<ul>
<li>默认的命名规则为：实体类名.hbm.xml</li>
<li>在xml配置文件中引入约束（引入的是hibernate3.0的dtd约束，不要引入4的约束）  <!DOCTYPE hibernate-mapping PUBLIC 
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
      "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
</li>
</ul>
</li>
<li><p>如果不能上网，编写配置文件是没有提示的，需要自己来配置</p>
<ul>
<li>先复制<a href="http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd" target="_blank" rel="noopener">http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd</a> –&gt; window –&gt; preferences –&gt; 搜索xml –&gt; 选择xml catalog –&gt; 点击add –&gt; 现在URI –&gt; 粘贴复制的地址 –&gt; 选择location，选择本地的DTD的路径</li>
</ul>
</li>
<li><p>编写映射的配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Generated 2017-5-29 10:19:21 by Hibernate Tools 3.4.0.CR1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"top.bcoder.bean.Customer"</span> <span class="attr">table</span>=<span class="string">"CUSTOMER"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"ID"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"NAME"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"AGE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"SEX"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"CITY"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<p><strong>第六步：编写Hibernate核心的配置文件</strong></p>
<ol>
<li><p>在src目录下，创建名称为hibernate.cfg.xml的配置文件</p>
</li>
<li><p>在XML中引入DTD约束</p>
<pre><code>&lt;!DOCTYPE hibernate-configuration PUBLIC
    &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</code></pre></li>
<li><p>打开：资料/hibernate-release-5.0.7.Final/project/etc/hibernate.properties，可以查看具体的配置信息    </p>
<pre><code>* 必须配置的4大参数                    
    #hibernate.connection.driver_class com.mysql.jdbc.Driver
    #hibernate.connection.url jdbc:mysql:///test
    #hibernate.connection.username gavin
    #hibernate.connection.password

* 数据库的方言（必须配置的）
    #hibernate.dialect org.hibernate.dialect.MySQLDialect

* 可选的配置
    #hibernate.show_sql true
    #hibernate.format_sql true
    #hibernate.hbm2ddl.auto update

* 引入映射配置文件（一定要注意，要引入映射文件，框架需要加载映射文件）</code></pre></li>
</ol>
<ol start="4">
<li>具体的配置如下<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">		<span class="meta-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span></span><br><span class="line"><span class="meta">		<span class="meta-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///hib<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"top/bcoder/bean/Customer.hbm.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>第七步：编写Hibernate入门代码</strong>    </p>
<p>Demo1: 添加用户</p>
<ol>
<li>具体的代码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Configuration configuration = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> SessionFactory sessionFactory = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> Session session = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">		sessionFactory = configuration.buildSessionFactory();</span><br><span class="line">		session = sessionFactory.openSession();</span><br><span class="line">		tx = session.beginTransaction();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@org</span>.junit.Test</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Customer customer = <span class="keyword">new</span> Customer(<span class="keyword">null</span>, <span class="string">"王五"</span>, <span class="number">20</span>, <span class="string">"男"</span>, <span class="string">"上海"</span>);</span><br><span class="line">		session.save(customer);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@After</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">		tx.commit();</span><br><span class="line">		session.close();</span><br><span class="line">		sessionFactory.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>demo2:修改客户年龄</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Customer customer = <span class="keyword">new</span> Customer(<span class="number">1</span>, <span class="string">"王五"</span>, <span class="number">30</span>, <span class="string">"男"</span>, <span class="string">"上海"</span>);</span><br><span class="line">	session.update(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo3:查询id=1的客户信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Customer customer = (Customer) session.get(Customer<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Customer [id&#x3D;1, name&#x3D;王五, age&#x3D;30, sex&#x3D;男, city&#x3D;上海]</span><br></pre></td></tr></table></figure>

<p>demo4:删除id=1的客户信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Customer customer = (Customer) session.get(Customer<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line">	session.delete(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Hibernate配置文件之映射配置文件"><a href="#Hibernate配置文件之映射配置文件" class="headerlink" title="Hibernate配置文件之映射配置文件"></a>Hibernate配置文件之映射配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> </span></span><br><span class="line"><span class="meta">	<span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"</span>&gt;</span>	</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"cn.javass.user.vo.UserModel"</span> <span class="attr">table</span>=<span class="string">"tbl_user"</span> &gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"userId"</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"uuid"</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    		&lt;version/&gt;：使用版本控制来处理并发，要开启optimistic-lock="version"和dynamic-update="true"。</span></span><br><span class="line"><span class="comment">			name="version"：持久化类的属性名，column="version"：指定持有版本号的字段名；</span></span><br><span class="line"><span class="comment">    	 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">version</span> <span class="attr">name</span>=<span class="string">"version"</span> <span class="attr">column</span>=<span class="string">"version"</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			组件映射：把多个属性打包在一起当一个属性使用，用来把类的粒度变小。</span></span><br><span class="line"><span class="comment">			&lt;component name="属性，这里指对象"&gt;</span></span><br><span class="line"><span class="comment">			 	&lt;property name="name1"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">			 	&lt;property name="name2"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">		 	&lt;/component&gt;</span></span><br><span class="line"><span class="comment">		 --&gt;</span></span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		 	&lt;join&gt;:一个对象映射多个表，该元素必须放在所有&lt;property&gt;之后。</span></span><br><span class="line"><span class="comment">		 	&lt;join table="tbl_test：子表名"&gt;</span></span><br><span class="line"><span class="comment">		 		&lt;key column="uuid：子表主键"&gt;&lt;/key&gt;</span></span><br><span class="line"><span class="comment">		 	&lt;property name="name1：对象属性" column="name：子表字段"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">		 &lt;/join&gt;</span></span><br><span class="line"><span class="comment">		  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="hibernate-mapping标签"><a href="#hibernate-mapping标签" class="headerlink" title="hibernate-mapping标签"></a>hibernate-mapping标签</h3><p><code>&lt;hibernate-mapping&gt;</code>一般不去配置，采用默认即可。</p>
<ul>
<li>schema:指定映射数据库的schema(模式/数据库)，如果指定该属性，则表名会自动添加该schema前缀</li>
<li>package:指定包前缀 指定持久化类所在的包名 这样之后calss子元素中就不必使用全限定性的类名</li>
<li>default-cascade=”none”：默认的级联风格，表与表联动。</li>
<li>default-lazy=”true”：默认延迟加载</li>
</ul>
<h3 id="class标签"><a href="#class标签" class="headerlink" title="class标签"></a>class标签</h3><p><code>&lt;class&gt;</code>：使用class元素定义一个持久化类。</p>
<ul>
<li>name=”cn.javass.user.vo.UserModel”：持久化类的java全限定名；</li>
<li>table=”tbl_user”：对应数据库表名，默认持久化类名作为表名；</li>
<li>proxy:指定一个接口，在延迟装载时作为代理使用，也可在这里指定该类自己的名字。</li>
<li>mutable=”true”：默认为true，设置为false时则不可以被应用程序更新或删除，等价于所有<code>&lt;property&gt;</code>元素的update属性为false，表示整个实例不能被更新。</li>
<li>dynamic-insert=”false”：默认为false，动态修改那些有改变过的字段，而不用修改所有字段；</li>
<li>dynamic-update=”false”：默认为false，动态插入非空值字段；</li>
<li>select-before-update=”false”：默认为false，在修改之前先做一次查询，与用户的值进行对比，有变化都会真正更新；</li>
<li>optimistic-lock=”version”：默认为version(检查version/timestamp字段)，<ul>
<li>取值：<ul>
<li>all(检查全部字段)、</li>
<li>dirty(只检查修改过的字段)</li>
<li>none(不使用乐观锁定)</li>
</ul>
</li>
<li>此参数主要用来处理并发，每条值都有固定且唯一的版本，版本为最新时才能执行操作；<br>如果需要采用继承映射，则class元素下还会增加<code>&lt;subclass.../&gt;</code>元素等用于定义子类。</li>
</ul>
</li>
</ul>
<h3 id="id标签"><a href="#id标签" class="headerlink" title="id标签"></a>id标签</h3><p><code>&lt;id&gt;</code>：定义了该属性到数据库表主键字段的映射</p>
<ul>
<li>type  指定该标识属性的数据类型，该类型可以是Hibernate的内建类型，也可以是java类型，如果是java类型则需要使用全限定类名（带包名）。该属性可选，如果没有指定类型， 则hibernate自行判断该标识属性数据类型。通常建议设定。</li>
<li>name=”userId”：标识属性的名字；</li>
<li>column=”userId”：表主键字段的名字，如果不填写与name一样；</li>
</ul>
<h3 id="generator主键生成"><a href="#generator主键生成" class="headerlink" title="generator主键生成"></a>generator主键生成</h3><p><code>&lt;generator&gt;</code>：指定主键由什么生成，推荐使用uuid，assigned指用户手工填入。设定标识符生成器</p>
<ol>
<li><p>创建表的时候</p>
<ul>
<li>自然主键:对象本身的一个属性.创建一个人员表,每个人都有一个身份证号.(唯一的)使用身份证号作为表的主键.自然主键.（开发中不会使用这种方式）</li>
<li>代理主键:不是对象本身的一个属性.创建一个人员表,为每个人员单独创建一个字段.用这个字段作为主键.代理主键.（开发中推荐使用这种方式）</li>
</ul>
</li>
<li><p>创建表的时候尽量使用代理主键创建表</p>
</li>
</ol>
<hr>
<p>主键生成可能取得值为：</p>
<ol>
<li><p>increment:适用于short,int,long作为主键.不是使用的数据库自动增长机制.</p>
<ul>
<li><p>Hibernate中提供的一种增长机制.</p>
<ul>
<li>先进行查询    :select max(id) from user;</li>
<li>再进行插入    :获得最大值+1作为新的记录的主键.</li>
</ul>
</li>
<li><p>问题:不能在集群环境下或者有并发访问的情况下使用.</p>
</li>
</ul>
</li>
<li><p>identity:适用于short,int,long作为主键。但是这个必须使用在有自动增长数据库中.采用的是数据库底层的自动增长机制.</p>
<ul>
<li>底层使用的是数据库的自动增长(auto_increment).像Oracle数据库没有自动增长.</li>
</ul>
</li>
<li><p>sequence:适用于short,int,long作为主键.底层使用的是序列的增长方式.</p>
<ul>
<li>Oracle数据库底层没有自动增长,想自动增长需要使用序列.</li>
</ul>
</li>
<li><p>uuid:适用于char,varchar类型的作为主键.</p>
<ul>
<li>使用随机的字符串作为主键.</li>
</ul>
</li>
<li><p>native:本地策略.根据底层的数据库不同,自动选择适用于该种数据库的生成策略.(short,int,long)</p>
<ul>
<li>如果底层使用的MySQL数据库:相当于identity.</li>
<li>如果底层使用Oracle数据库:相当于sequence.</li>
</ul>
</li>
<li><p>assigned:主键的生成不用Hibernate管理了.必须手动设置主键.    </p>
</li>
</ol>
<h3 id="property标签"><a href="#property标签" class="headerlink" title="property标签"></a>property标签</h3><p><code>&lt;property&gt;</code>：为类定义一个持久化的javaBean风格的属性。</p>
<ul>
<li>name=”name”：标识属性的名字，以小写字母开头；</li>
<li>column=”name”：表主键字段的名字，如果不填写与name一样；</li>
<li>update=”true”/insert=”true”：默认为true，表示可以被更新或插入；</li>
<li>access=”property/field”：指定Hibernate访问持久化类属性的方式。默认property。property表示使用setter/getter方式。field表示运用java反射机制直接访问类的属性。</li>
<li>formula=”{select。。。。。}”：该属性指定一个SLQ表达式，指定该属性的值将根据表达式类计算，计算属性没有和它对应的数据列。</li>
<li>formula属性允许包含表达式：sum,average,max函数求值的结果。<pre><code>例如：formula=&quot;(select avg(p.price) from Product P)&quot;</code></pre></li>
<li>length        – 数据长度</li>
<li>type            – 数据类型（一般都不需要编写，如果写需要按着规则来编写）<ul>
<li>Hibernate的数据类型    type=”string”</li>
<li>Java的数据类型        type=”java.lang.String”</li>
<li>数据库字段的数据类型    <column name="name" sql-type="varchar"/></li>
</ul>
</li>
</ul>
<h2 id="Hibernate配置文件之核心配置文件"><a href="#Hibernate配置文件之核心配置文件" class="headerlink" title="Hibernate配置文件之核心配置文件"></a>Hibernate配置文件之核心配置文件</h2><ol>
<li>核心配置文件的两种方式</li>
</ol>
<ul>
<li><p>第一种方式是属性文件的形式，即properties的配置文件</p>
<ul>
<li>hibernate.properties<ul>
<li>hibernate.connection.driver_class=com.mysql.jdbc.Driver</li>
</ul>
</li>
<li>缺点<ul>
<li>不能加载映射的配置文件，需要手动编写代码去加载</li>
</ul>
</li>
</ul>
</li>
<li><p>第二种方式是XML文件的形式，开发基本都会选择这种方式</p>
<ul>
<li>hibernate.cfg.xml<ul>
<li><property name="hibernate.connection.driver_class" >com.mysql.jdbc.Driver</property></li>
</ul>
</li>
<li>优点<ul>
<li>格式比较清晰</li>
<li>编写有提示</li>
<li>可以在该配置文件中加载映射的配置文件（最主要的）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>关于hibernate.cfg.xml的配置文件方式</li>
</ol>
<ul>
<li><p>必须有的配置</p>
<ul>
<li><p>数据库连接信息:<br>  hibernate.connection.driver_class              – 连接数据库驱动程序<br>  hibernate.connection.url                       – 连接数据库URL<br>  hibernate.connection.username                  – 数据库用户名<br>  hibernate.connection.password               – 数据库密码</p>
</li>
<li><p>方言:<br>  hibernate.dialect                           – 操作数据库方言</p>
</li>
</ul>
</li>
<li><p>可选的配置</p>
<ul>
<li>hibernate.show_sql                            – 显示SQL</li>
<li>hibernate.format_sql                            – 格式化SQL</li>
<li>hibernate.hbm2ddl.auto                        – 通过映射转成DDL语句<ul>
<li>create                – 每次都会创建一个新的表.—测试的时候</li>
<li>create-drop            – 每次都会创建一个新的表,当执行结束之后,将创建的这个表删除.—测试的时候</li>
<li>update                – 如果有表,使用原来的表.没有表,创建一个新的表.同时更新表结构.</li>
<li>validate                – 如果有表,使用原来的表.同时校验映射文件与表中字段是否一致如果不一致就会报错.</li>
</ul>
</li>
</ul>
</li>
<li><p>加载映射</p>
<ul>
<li>如果XML方式：·<code>&lt;mapping resource=&quot;cn/hibernate/domain/User.hbm.xml&quot; /&gt;</code></li>
</ul>
</li>
</ul>
<p>配置文件示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定Hibernate配置文件的DTD信息 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- hibernate- configuration是连接配置文件的根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定连接数据库所用的驱动 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定连接数据库的url，hibernate连接的数据库名 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.url"</span>&gt;</span>jdbc:mysql://localhost/数据库名<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定连接数据库的用户名 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定连接数据库的密码 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.password"</span>&gt;</span>32147<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定连接池里最大连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.max_size"</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定连接池里最小连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.min_size"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定连接池里连接的超时时长 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.timeout"</span>&gt;</span>5000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.max_statements"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.idle_test_period"</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.acquire_increment"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.validate"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定数据库方言 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQLInnoDBDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 根据需要自动创建数据表 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 显示Hibernate持久化操作所生成的SQL --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 将SQL脚本进行格式化后再输出 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 罗列所有的映射文件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"映射文件路径/News.hbm.xml"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>部分属性讲解：<br>dialect:数据库方言，必要配置，常用的如下：</p>
<ul>
<li>DB2 <ul>
<li>org.hibernate.dialect.DB2Dialect</li>
</ul>
</li>
<li>MySQL    <ul>
<li>org.hibernate.dialect.MySQLDialect</li>
</ul>
</li>
<li>MySQL with InnoDB    <ul>
<li>org.hibernate.dialect.MySQLInnoDBDialect</li>
</ul>
</li>
<li>MySQL with MyISAM    <ul>
<li>org.hibernate.dialect.MySQLMyISAMDialect</li>
</ul>
</li>
<li>Oracle (any version)    <ul>
<li>org.hibernate.dialect.OracleDialect</li>
</ul>
</li>
<li>Oracle 9i/10g    <ul>
<li>org.hibernate.dialect.Oracle9Dialect</li>
</ul>
</li>
<li>Microsoft SQL Server<ul>
<li>org.hibernate.dialect.SQLServerDialect</li>
</ul>
</li>
</ul>
<hr>
<p>hbm2ddl.auto:数据表生成策略：常用的值有：</p>
<ul>
<li>create：<ul>
<li>每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。</li>
</ul>
</li>
<li>create-drop ：<ul>
<li>每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。</li>
</ul>
</li>
<li>update：<ul>
<li>最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。</li>
</ul>
</li>
<li>validate ：<ul>
<li>每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</li>
</ul>
</li>
</ul>
<h2 id="Hibernate核心API"><a href="#Hibernate核心API" class="headerlink" title="Hibernate核心API"></a>Hibernate核心API</h2><h3 id="Configuration类"><a href="#Configuration类" class="headerlink" title="Configuration类"></a>Configuration类</h3><ol>
<li><p>Configuration类</p>
<ul>
<li><p>Configuration对象用于配置并且启动Hibernate。</p>
</li>
<li><p>Hibernate应用通过该对象来获得对象-关系映射文件中的元数据，以及动态配置Hibernate的属性，然后创建SessionFactory对象。</p>
</li>
<li><p>简单一句话：加载Hibernate的配置文件，可以获取SessionFactory对象。</p>
</li>
</ul>
</li>
<li><p>Configuration类的其他应用（了解）</p>
<ul>
<li><p>加载配置文件的种类，Hibernate支持xml和properties类型的配置文件，在开发中基本都使用XML配置文件的方式。</p>
<ul>
<li><p>如果采用的是properties的配置文件，那么通过Configuration configuration = new Configuration();就可以加载配置文件但是需要自己手动加载映射文件例如：config.addResource(“cn/itcast/domain/Student.hbm.xml”);</p>
</li>
<li><p>如果采用的XML的配置文件，通过Configuration configuration = new Configuration().configure();加载配置文件</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="SessionFactory类"><a href="#SessionFactory类" class="headerlink" title="SessionFactory类"></a>SessionFactory类</h3><ol>
<li><p>SessionFactory是工厂类，是生成Session对象的工厂类</p>
</li>
<li><p>SessionFactory类的特点</p>
<ul>
<li><p>由Configuration通过加载配置文件创建该对象。</p>
</li>
<li><p>SessionFactory对象中保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句。同时，SessionFactory还负责维护Hibernate的二级缓存。</p>
</li>
<li><p>预定义SQL语句</p>
<ul>
<li>使用Configuration类创建了SessionFactory对象是，已经在SessionFacotry对象中缓存了一些SQL语句</li>
<li>常见的SQL语句是增删改查（通过主键来查询）</li>
<li>这样做的目的是效率更高</li>
</ul>
</li>
<li><p>一个SessionFactory实例对应一个数据库，应用从该对象中获得Session实例。</p>
</li>
<li><p>SessionFactory是线程安全的，意味着它的一个实例可以被应用的多个线程共享。</p>
</li>
<li><p>SessionFactory是重量级的，意味着不能随意创建或销毁它的实例。如果只访问一个数据库，只需要创建一个SessionFactory实例，且在应用初始化的时候完成。</p>
</li>
<li><p>SessionFactory需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为Hibernate的二级缓存，被多线程所共享</p>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>一般应用使用一个SessionFactory,最好是应用启动时就完成初始化。</li>
</ul>
</li>
</ol>
<p>demo:HibernateUtil的工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtil</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Configuration cfg;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SessionFactory factory;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		<span class="comment">// 给常量赋值 </span></span><br><span class="line">		<span class="comment">// 加载配置文件</span></span><br><span class="line">		cfg = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">		<span class="comment">// 生成factory对象</span></span><br><span class="line">		factory = cfg.buildSessionFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取Session对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">openSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> factory.openSession();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session接口"><a href="#Session接口" class="headerlink" title="Session接口"></a>Session接口</h3><ol>
<li><p>概述</p>
<ul>
<li>Session是在Hibernate中使用最频繁的接口。也被称之为持久化管理器。它提供了和持久化有关的操作，比如添加、修改、删除、加载和查询实体对象</li>
<li>Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心</li>
<li>Session是线程不安全的</li>
<li>所有持久化对象必须在 session 的管理下才可以进行持久化操作</li>
<li>Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久化操作的数据都缓存在 session 对象处</li>
<li>持久化类与 Session 关联起来后就具有了持久化的能力</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>不是线程安全的。应避免多个线程使用同一个Session实例</li>
<li>Session是轻量级的，它的创建和销毁不会消耗太多的资源。应为每次客户请求分配独立的Session实例</li>
<li>Session有一个缓存，被称之为Hibernate的一级缓存。每个Session实例都有自己的缓存</li>
</ul>
</li>
<li><p>常用的方法</p>
<ul>
<li>save(obj)</li>
<li>delete(obj)  </li>
<li>get(Class,id)</li>
<li>update(obj)</li>
<li>saveOrUpdate(obj)                    – 保存或者修改（如果没有数据，保存数据。如果有，修改数据）</li>
<li>createQuery()                     – HQL语句的查询的方式</li>
</ul>
</li>
</ol>
<p>4.扩展：session.openSession与session.getCurrentSession()的区别：<br>    请参看本人另一篇博文：<a  href="2017/05/29/Hibernate-openSession与getCurrentSession的区别/">Hibernate:openSession与getCurrentSession的区别</a></p>
<hr>
<h3 id="Transaction接口"><a href="#Transaction接口" class="headerlink" title="Transaction接口"></a>Transaction接口</h3><ol>
<li><p>Transaction是事务的接口</p>
</li>
<li><p>常用的方法</p>
<ul>
<li>commit()                – 提交事务</li>
<li>rollback()            – 回滚事务</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>Hibernate框架默认情况下事务不自动提交.需要手动提交事务</li>
<li>如果没有开启事务，那么每个Session的操作，都相当于一个独立的事务</li>
</ul>
</li>
</ol>
<h2 id="持久化对象的状态"><a href="#持久化对象的状态" class="headerlink" title="持久化对象的状态"></a>持久化对象的状态</h2><h3 id="持久化对象简介"><a href="#持久化对象简介" class="headerlink" title="持久化对象简介"></a>持久化对象简介</h3><ol>
<li><p>Hibernate的持久化类</p>
<ul>
<li>持久化类:Java类与数据库的某个表建立了映射关系.这个类就称为是持久化类.<ul>
<li>持久化类 = Java类 + hbm的配置文件</li>
</ul>
</li>
</ul>
</li>
<li><p>Hibernate的持久化类的状态</p>
<ul>
<li><p>Hibernate为了管理持久化类：将持久化类分成了三个状态</p>
<ul>
<li><p>瞬时态:Transient  Object</p>
<ul>
<li>没有持久化标识OID（有可能是刚new 出来并进行实例化的对象，并没有主键值）, 没有被纳入到Session对象的管理.</li>
</ul>
</li>
<li><p>持久态:Persistent Object</p>
<ul>
<li>有持久化标识OID,已经被纳入到Session对象的管理（已经加入到session缓存中）.</li>
<li>持久化状态时session未关闭前变成持久化状态的</li>
</ul>
</li>
<li><p>脱管态:Detached Object</p>
<ul>
<li>有持久化标识OID,没有被纳入到Session对象的管理.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>demo:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Customer customer = <span class="keyword">new</span> Customer(<span class="keyword">null</span>,  <span class="string">"qid"</span>, <span class="number">26</span>, <span class="string">"女"</span>, <span class="string">"河南"</span>);</span><br><span class="line">	System.out.println(<span class="string">"游离态："</span>+customer);</span><br><span class="line">	session.save(customer);</span><br><span class="line">	System.out.println(<span class="string">"持久态："</span>+customer);</span><br><span class="line">	tx.commit();</span><br><span class="line">	session.close();</span><br><span class="line">	System.out.println(<span class="string">"托管态："</span>+customer);</span><br><span class="line">	session = sessionFactory.openSession();</span><br><span class="line">	tx = session.beginTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">游离态：Customer [id&#x3D;null, name&#x3D;qid, age&#x3D;26, sex&#x3D;女, city&#x3D;河南]</span><br><span class="line">Hibernate: </span><br><span class="line">    insert </span><br><span class="line">    into</span><br><span class="line">        CUSTOMER</span><br><span class="line">        (NAME, AGE, SEX, CITY) </span><br><span class="line">    values</span><br><span class="line">        (?, ?, ?, ?)</span><br><span class="line">持久态：Customer [id&#x3D;6, name&#x3D;qid, age&#x3D;26, sex&#x3D;女, city&#x3D;河南]</span><br><span class="line">托管态：Customer [id&#x3D;6, name&#x3D;qid, age&#x3D;26, sex&#x3D;女, city&#x3D;河南]</span><br></pre></td></tr></table></figure>

<h3 id="三种状态的转化"><a href="#三种状态的转化" class="headerlink" title="三种状态的转化"></a>三种状态的转化</h3><p><img src="http://img.bcoder.top/2017.05.29/5.png" alt=""></p>
<p>1、transient 瞬时状态<br>new一个新的对象即为瞬时状态，瞬时状态和session没有关联，一个瞬时对象和数据库记录不对应。<br>瞬时对象—&gt;save或saveOrUpadate—-&gt;持久对象。</p>
<p>2、persistent 持久状态<br>持久状态对象和session有关联，持久对象和数据库记录存在对应，持久对象属性值变更可以持久到数据库中。<br>执行Get查询可以得到一个持久对象。<br>持久对象—&gt;delete删除—&gt;瞬时对象<br>持久对象–&gt;session.close（session关闭）—&gt;托管对象 </p>
<p>3、detached 托管状态<br>托管对象和session没有关联，它和瞬时对象的区别在于托管对象可能会和数据库记录存在对应。<br>托管对象——&gt;update或saveOrUpdate —&gt;持久对象</p>
<h2 id="Hibernate一级缓存"><a href="#Hibernate一级缓存" class="headerlink" title="Hibernate一级缓存"></a>Hibernate一级缓存</h2><h3 id="一级缓存概述"><a href="#一级缓存概述" class="headerlink" title="一级缓存概述"></a>一级缓存概述</h3><ol>
<li><p>什么是缓存？</p>
<ul>
<li>其实就是一块内存空间,将数据源（数据库或者文件）中的数据存放到缓存中.再次获取的时候 ,直接从缓存中获取.可以提升程序的性能！</li>
</ul>
</li>
<li><p>Hibernate框架提供了两种缓存</p>
<ul>
<li>一级缓存    – 自带的不可卸载的.一级缓存的生命周期与session一致.一级缓存称为session级别的缓存.</li>
<li>二级缓存    – 默认没有开启，需要手动配置才可以使用的.二级缓存可以在多个session中共享数据,二级缓存称为是sessionFactory级别的缓存.</li>
</ul>
</li>
<li><p>Session对象的缓存概述</p>
<ul>
<li>Session接口中,有一系列的java的集合,这些java集合构成了Session级别的缓存(一级缓存).将对象存入到一级缓存中,session没有结束生命周期,那么对象在session中存放着</li>
<li>内存中包含Session实例 –&gt; Session的缓存（一些集合） –&gt; 集合中包含的是缓存对象！</li>
<li>当session的save()方法持久化一个对象时，该对象被载入缓存，以后即使程序中不再引用该对象，只要缓存不清空，该对象仍然处于生命周期中。当试图get()、 load()对象时，会判断缓存中是否存在该对象，有则返回，此时不查询数据库。没有再查询数据库</li>
</ul>
</li>
<li><p>证明一级缓存的存在，编写查询的代码即可证明</p>
<ul>
<li>在同一个Session对象中两次查询，可以证明使用了缓存</li>
</ul>
</li>
<li><p>Hibernate框架是如何做到数据发生变化时进行同步操作的呢？</p>
<ul>
<li>使用get方法查询User对象</li>
<li>然后设置User对象的一个属性，注意：没有做update操作。发现，数据库中的记录也改变了。</li>
<li>利用快照机制来完成的（SnapShot）</li>
</ul>
</li>
</ol>
<p>Demo:证明session一级缓存的存在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo6</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Customer customer = (Customer) session.get(Customer<span class="class">.<span class="keyword">class</span>, 4)</span>;</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">	Customer customer2 = (Customer) session.get(Customer<span class="class">.<span class="keyword">class</span>, 4)</span>;</span><br><span class="line">	System.out.println(customer2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        customer0_.ID as ID1_0_0_,</span><br><span class="line">        customer0_.NAME as NAME2_0_0_,</span><br><span class="line">        customer0_.AGE as AGE3_0_0_,</span><br><span class="line">        customer0_.SEX as SEX4_0_0_,</span><br><span class="line">        customer0_.CITY as CITY5_0_0_ </span><br><span class="line">    from</span><br><span class="line">        CUSTOMER customer0_ </span><br><span class="line">    where</span><br><span class="line">        customer0_.ID&#x3D;?</span><br><span class="line">Customer [id&#x3D;4, name&#x3D;王五, age&#x3D;50, sex&#x3D;男, city&#x3D;上海]</span><br><span class="line">Customer [id&#x3D;4, name&#x3D;王五, age&#x3D;50, sex&#x3D;男, city&#x3D;上海]</span><br></pre></td></tr></table></figure>




<h3 id="控制一级缓存"><a href="#控制一级缓存" class="headerlink" title="控制一级缓存"></a>控制一级缓存</h3><ol>
<li>Session接口中与一级缓存相关的方法<pre><code>* Session.clear()                        -- 清空缓存。
* Session.evict(Object entity)            -- 从一级缓存中清除指定的实体对象。
* Session.flush()                        -- 刷出缓存</code></pre></li>
</ol>
<p>demo：一级缓存清除后再次查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo7</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Customer customer = (Customer) session.get(Customer<span class="class">.<span class="keyword">class</span>, 4)</span>;</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">	session.clear();</span><br><span class="line">	Customer customer2 = (Customer) session.get(Customer<span class="class">.<span class="keyword">class</span>, 4)</span>;</span><br><span class="line">	System.out.println(customer2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        customer0_.ID as ID1_0_0_,</span><br><span class="line">        customer0_.NAME as NAME2_0_0_,</span><br><span class="line">        customer0_.AGE as AGE3_0_0_,</span><br><span class="line">        customer0_.SEX as SEX4_0_0_,</span><br><span class="line">        customer0_.CITY as CITY5_0_0_ </span><br><span class="line">    from</span><br><span class="line">        CUSTOMER customer0_ </span><br><span class="line">    where</span><br><span class="line">        customer0_.ID&#x3D;?</span><br><span class="line">Customer [id&#x3D;4, name&#x3D;王五, age&#x3D;50, sex&#x3D;男, city&#x3D;上海]</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        customer0_.ID as ID1_0_0_,</span><br><span class="line">        customer0_.NAME as NAME2_0_0_,</span><br><span class="line">        customer0_.AGE as AGE3_0_0_,</span><br><span class="line">        customer0_.SEX as SEX4_0_0_,</span><br><span class="line">        customer0_.CITY as CITY5_0_0_ </span><br><span class="line">    from</span><br><span class="line">        CUSTOMER customer0_ </span><br><span class="line">    where</span><br><span class="line">        customer0_.ID&#x3D;?</span><br><span class="line">Customer [id&#x3D;4, name&#x3D;王五, age&#x3D;50, sex&#x3D;男, city&#x3D;上海]</span><br></pre></td></tr></table></figure>

<h3 id="一级缓存的快照机制"><a href="#一级缓存的快照机制" class="headerlink" title="一级缓存的快照机制"></a>一级缓存的快照机制</h3><p>先用一张图来简单说明一下：</p>
<p><img src="http://img.bcoder.top/2017.05.29/6.bmp" alt=""></p>
<p>（1）、快照是数据的副本<br>（2）、快照属于一级缓存<br>（3）、快照是在堆内存中的<br>（4）、快照的作用：保证数据一致性<br>demo:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo8</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Customer customer = (Customer) session.get(Customer<span class="class">.<span class="keyword">class</span>, 4)</span>;</span><br><span class="line">		System.out.println(<span class="string">"customer"</span>+customer);</span><br><span class="line">		customer.setAge(<span class="number">10</span>);</span><br><span class="line">		Customer customer2 = (Customer) session.get(Customer<span class="class">.<span class="keyword">class</span>, 4)</span>;</span><br><span class="line">		System.out.println(<span class="string">"customer2"</span>+customer2);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        customer0_.ID <span class="keyword">as</span> ID1_0_0_,</span><br><span class="line">        customer0_.NAME <span class="keyword">as</span> NAME2_0_0_,</span><br><span class="line">        customer0_.AGE <span class="keyword">as</span> AGE3_0_0_,</span><br><span class="line">        customer0_.SEX <span class="keyword">as</span> SEX4_0_0_,</span><br><span class="line">        customer0_.CITY <span class="keyword">as</span> CITY5_0_0_ </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        CUSTOMER customer0_ </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        customer0_.ID=?</span><br><span class="line">customerCustomer [<span class="keyword">id</span>=<span class="number">4</span>, <span class="keyword">name</span>=王五, age=<span class="number">50</span>, sex=男, city=上海]</span><br><span class="line">customer2Customer [<span class="keyword">id</span>=<span class="number">4</span>, <span class="keyword">name</span>=王五, age=<span class="number">10</span>, sex=男, city=上海]</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        CUSTOMER </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        <span class="keyword">NAME</span>=?,</span><br><span class="line">        AGE=?,</span><br><span class="line">        SEX=?,</span><br><span class="line">        CITY=? </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">ID</span>=?</span><br></pre></td></tr></table></figure>

<p>分析</p>
<p>我们都知道，执行了get方法之后，DB中的数据就加载到session缓存中来了，而执行customer.setAge(10);本来应该只是改变了session缓存（堆内存）中的数据，为什么数据库的数据也改变了。<br>再来解剖一下Customer customer = (Customer) session.get(Customer.class, 4);<br>1）、将数据从DB中取出来</p>
<p>2）、将数据转变成对象，并存入堆内存中</p>
<p>3）、将对象的id放入session缓存map的key中，将对象的引用放入session缓存map的 value中，这就纳入session管理了<br>4）、将对象的详情放入到“快照”中<br>当执行了`session.getTransaction().commit();时，Hibernate为了保证数据的一致性，Hibernate会清理session的一级缓存（flush），也就是将堆内存中的数据（已经纳入session管理的数据）与快照中的数据进行对比，如果不一致，则会执行同步（update）操作，若相同，则不执行update。</p>
<p>下面一个例子能更好的证明快照就是缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo9</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Customer customer = (Customer) session.get(Customer<span class="class">.<span class="keyword">class</span>, 4)</span>;</span><br><span class="line">	System.out.println(<span class="string">"customer"</span>+customer);</span><br><span class="line">	customer.setAge(<span class="number">50</span>);</span><br><span class="line">	Customer customer2 = (Customer) session.get(Customer<span class="class">.<span class="keyword">class</span>, 4)</span>;</span><br><span class="line">	System.out.println(<span class="string">"customer2"</span>+customer2);</span><br><span class="line">	session.clear();</span><br><span class="line">	Customer customer3 = (Customer) session.get(Customer<span class="class">.<span class="keyword">class</span>, 4)</span>;</span><br><span class="line">	System.out.println(<span class="string">"customer3"</span>+customer3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        customer0_.ID <span class="keyword">as</span> ID1_0_0_,</span><br><span class="line">        customer0_.NAME <span class="keyword">as</span> NAME2_0_0_,</span><br><span class="line">        customer0_.AGE <span class="keyword">as</span> AGE3_0_0_,</span><br><span class="line">        customer0_.SEX <span class="keyword">as</span> SEX4_0_0_,</span><br><span class="line">        customer0_.CITY <span class="keyword">as</span> CITY5_0_0_ </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        CUSTOMER customer0_ </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        customer0_.ID=?</span><br><span class="line">customerCustomer [<span class="keyword">id</span>=<span class="number">4</span>, <span class="keyword">name</span>=王五, age=<span class="number">10</span>, sex=男, city=上海]</span><br><span class="line">customer2Customer [<span class="keyword">id</span>=<span class="number">4</span>, <span class="keyword">name</span>=王五, age=<span class="number">50</span>, sex=男, city=上海]</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        customer0_.ID <span class="keyword">as</span> ID1_0_0_,</span><br><span class="line">        customer0_.NAME <span class="keyword">as</span> NAME2_0_0_,</span><br><span class="line">        customer0_.AGE <span class="keyword">as</span> AGE3_0_0_,</span><br><span class="line">        customer0_.SEX <span class="keyword">as</span> SEX4_0_0_,</span><br><span class="line">        customer0_.CITY <span class="keyword">as</span> CITY5_0_0_ </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        CUSTOMER customer0_ </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        customer0_.ID=?</span><br><span class="line">customer3Customer [<span class="keyword">id</span>=<span class="number">4</span>, <span class="keyword">name</span>=王五, age=<span class="number">10</span>, sex=男, city=上海]</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>此demo在上一个demo的基础上加了一句话：session.clear();<br>在事务提交之前，将缓存清除（快照也随之清除），数据库的值不会发生改变<br>此运行流程为：<br>1.Customer customer = (Customer) session.get(Customer.class, 4);：查询id为4的客户信息，此客户对象不在session缓存中，因此发送SQL语句进行查询数据库，把查询到的对象放在session缓存中，对象变成持久态，同时快照中也会复制一份对象<br>2.customer.setAge(50);：id为4的客户信息的年龄改为50，更新一级缓存<br>3.Customer customer2 = (Customer) session.get(Customer.class, 4);：再次查询id为4的客户信息，发现session缓存中存在，直接将缓存中的客户信息获得（此时客户年龄为50）<br>4.session.clear();：清除缓存，将缓存和快照的数据全部清空（之前将缓存中客户年龄改为50的记录被清空）<br>5.Customer customer3 = (Customer) session.get(Customer.class, 4);:查询id为4的客户信息，此客户对象不在session缓存中(缓存为空)，因此发送SQL语句进行查询数据库，把查询到的对象放在session缓存中。</p>
<h2 id="Hibernate关联关系映射："><a href="#Hibernate关联关系映射：" class="headerlink" title="Hibernate关联关系映射："></a>Hibernate关联关系映射：</h2><h3 id="一对一关系映射"><a href="#一对一关系映射" class="headerlink" title="一对一关系映射"></a>一对一关系映射</h3><p>一对一关系看起来简单，其实也挺复杂的。其中关系就包含了四种，单向双向和主键关联外键关联。 什么意思呢，也就是包含了单向一对一主键关联、双向一对一主键关联，单向一对一外键关联，双向一对一外键关联， 这四种中，单双向就不用在说了把，就是看你业务需求来去设置是否是单双向，而外键关联也很简单，前面的一对多和多对多度是依靠外键关联关系来写的。那主键关联关系是怎么样的呢？其实跟外键关联差不多，唯一的区别就是，让一个类的主键当作外键使用来指向另一个关联类的主键，从而两个类的主键就达到了同步，也就是一致。你的主键是什么我的主键就是什么。如果这看不懂，那么就看下面的详细讲解的。</p>
<h4 id="单向一对一主键关联"><a href="#单向一对一主键关联" class="headerlink" title="单向一对一主键关联"></a>单向一对一主键关联</h4><p>通过人和身份证这个一对一的例子来解释。</p>
<p>实体类的属性</p>
<p><img src="http://img.bcoder.top/2017.05.29/7.png" alt="">　　　　　　　　　　　　　　　　　</p>
<p>数据库关系图</p>
<p><img src="http://img.bcoder.top/2017.05.29/8.png" alt="">　　</p>
<p>person中的id既是主键又是指向IdCard主键的外键。通过外键得特性，可以知道person的id和IdCard的主键id要相同，所以这才叫做主键关系。</p>
<p>　　　　　　　　　　　　　　　　　　　</p>
<p>IdCard.java和IdCard.hbm.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String cardNo;</span><br><span class="line">  <span class="comment">//....  </span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>IdCard.hbm.xml<br>这个没什么好说的，因为是单向一对一，这个就正常写，他不用干什么。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain1.IdCard"</span> <span class="attr">table</span>=<span class="string">"idcard"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 主键生成策略 使用native，需要底层数据库自己设置主键的值哦，比如AUTO_INCREMENT --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">generator</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一些常规属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cardNo"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>Person.java和Person.hbm.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> IdCard idCard;<span class="comment">//体现一对一的关系。保存映射类的实例对象。</span></span><br><span class="line"><span class="comment">//..............</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>Person.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain1.Person"</span> <span class="attr">table</span>=<span class="string">"person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 重点在这里。主键生成策略 因为主键跟外键是同一个，所以直接在这里申明该主键就是外键，并且指向了idCard这个类 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"foreign"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span>idCard<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">generator</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一些常规属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--由于在申明主键的时候已经将关系写清楚了，所以在这里没有column这个属性。按平常的习惯，我们会在这里写上column="数据库中外键字段属性名称。"--&gt;</span></span><br><span class="line">　　　　<span class="comment">&lt;!--constrained属性：就是表明我们的主键当外键使用了。 这个属性两个作用，一是通知这种对应关系在上面已经写过了，所以这里才不需要写column，二是表明这种关系是什么，也就是主键当外键。</span></span><br><span class="line"><span class="comment">　　　　　　其实还有一个级联关系的作用，这里不做多说明。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"idCard"</span> <span class="attr">constrained</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-one</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>添加测试数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	IdCard idCard = <span class="keyword">new</span> IdCard();</span><br><span class="line">       idCard.setCardNo(<span class="string">"11111111"</span>);</span><br><span class="line">       </span><br><span class="line">       Person person = <span class="keyword">new</span> Person();</span><br><span class="line">       person.setName(<span class="string">"qqq"</span>);</span><br><span class="line">       </span><br><span class="line">       person.setIdCard(idCard);</span><br><span class="line">       </span><br><span class="line">       session.save(idCard);<span class="comment">//这个其实可以不用的，讲了级联就可以省略的，现在先保留下来</span></span><br><span class="line">       session.save(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据库图：<br><img src="http://img.bcoder.top/2017.05.29/9.png" alt="">　　</p>
<p>现在来真正测试一下这个单向一对一主键关系</p>
<p>　　　　</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样会报异常，因为我们设置的是单向一对一，从person到Idcard，所以从idcard是查不到person。java.lang.NullPointerException</span></span><br><span class="line">IdCard idCard = (IdCard)session.get(IdCard<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line">        </span><br><span class="line">System.out.println(idCard.getPerson().getName());;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是这样就查得到一个人的idCard</span></span><br><span class="line">Person person = (Person)session.get(Person<span class="class">.<span class="keyword">class</span>，1)</span>;</span><br><span class="line">                person.getIdCard().getCardNo();</span><br></pre></td></tr></table></figure>
<p>到这里，单向一对一主键关联就讲解完了，知道了单向，双向就so easy了，</p>
<h4 id="双向一对一主键关联"><a href="#双向一对一主键关联" class="headerlink" title="双向一对一主键关联"></a>双向一对一主键关联</h4><p>实体类属性<br><img src="http://img.bcoder.top/2017.05.29/10.png" alt="">　　</p>
<p>这个图中双向箭头的意思是不管从那边查找，度能够找到对方，比如，person到Idcard：直接拿自己的主键值到对方表中查找主键值一样的，查找到了就将该记录放到自己的idCard属性中，就行了  idCard到person也是一样，拿主键值到对方表中查找主键值相同的。查找到了就将记录放到person属性变量中。</p>
<p>　　　　　　　　　　　　<br>数据库关系</p>
<p><img src="http://img.bcoder.top/2017.05.29/11.png" alt="">　　
　　　　　　　　　　　　　　</p>
<p>跟单向一对一主键关系基本上一样，只需要在IdCard这个实体类上加上一个Person person来保存对应的person实例对象，并且在IdCard.hbm.xml中加上一个<one-to-one>的映射关系，来看一下</p>
<p>其他度不变，我写出来的就是要变化的</p>
<p>IdCard.java和IdCard.hbm.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String cardNo;</span><br><span class="line">    <span class="keyword">private</span> Person person;<span class="comment">//多了这个</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IdCard.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain1.IdCard"</span> <span class="attr">table</span>=<span class="string">"idcard"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 主键生成策略 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">generator</span>&gt;</span>        </span><br><span class="line">	<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 一些常规属性 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cardNo"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 这里只需要写这些就足够了，因为one-to-one默认使用的就是用主键跟关联类的主键进行比较，本来就是主键关系，通过主键跟主键比较，就能达到目的，所以这个中没有column这个属性，但是可以配置一些别的属性，不需要写column， --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"person"</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-one</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>测试</p>
<p>现在在通过Idcard查找person就不会报异常了，可以找到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> IdCard idCard = (IdCard)session.get(IdCard<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line">        </span><br><span class="line">System.out.println(idCard.getPerson().getName());;</span><br></pre></td></tr></table></figure>
<p>运行发送的sql语句和结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        idcard0_.id <span class="keyword">as</span> id3_1_,</span><br><span class="line">        idcard0_.cardNo <span class="keyword">as</span> cardNo3_1_,</span><br><span class="line">        person1_.id <span class="keyword">as</span> id4_0_,</span><br><span class="line">        person1_.name <span class="keyword">as</span> name4_0_ </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        idcard idcard0_ </span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">        person person1_ </span><br><span class="line">            <span class="keyword">on</span> idcard0_.id=person1_.id </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        idcard0_.id=?</span><br><span class="line">qqq</span><br></pre></td></tr></table></figure>

<p>注意：主键关系的一对一的缺点：不知道你们发现了没有，在增加实验数据的时候，必须得先有Idcard，才能有person，</p>
<h4 id="单向一对一外键关联"><a href="#单向一对一外键关联" class="headerlink" title="单向一对一外键关联"></a>单向一对一外键关联</h4><p>理解了主键关联，这个外键关系非常简单，因为他就是多对一的一个特例，如果多端控制为1个的话，那不就是一对一了吗，这里要注意站的角度问题，多对一重点在多端，如果是一对多的话，重点在一端，一端本来就是1了，就没有所谓的特例了，所以还是要到多端去设置让他唯一，这样就打到了一对一关系，因此上面说的是多对一的一个特例，这样解释应该清楚了。如何设置多端唯一呢，通过一个属性 unique=ture。</p>
<p>来看看数据库关系图(跟一对多的数据库关系模型一样)</p>
<p><img src="http://img.bcoder.top/2017.05.29/12.png" alt=""></p>
<p>实体类中属性</p>
<p><img src="http://img.bcoder.top/2017.05.29/13.png" alt=""></p>
<p>因为是单向一对一，从Person到IdCard，所以Person中多一个能存放IdCard实例对象的属性</p>
<p>　　　　　　　　　　<br>IdCard.java和IdCard.hbm.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String cardNo;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain1.IdCard"</span> <span class="attr">table</span>=<span class="string">"idcard"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 主键生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">generator</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一些常规属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cardNo"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>Person.java和Person.hbm.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> IdCard idCard;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>Person.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain1.Person"</span> <span class="attr">table</span>=<span class="string">"person"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 主键生成策略 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">generator</span>&gt;</span>        </span><br><span class="line">	<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 一些常规属性 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">　　　　<span class="comment">&lt;!--跟多对一一样，只是增加了一个unique属性。这样就指定了这端为一了。--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"idCard"</span> <span class="attr">column</span>=<span class="string">"cardId"</span> <span class="attr">unique</span>=<span class="string">true</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>增加测试数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IdCard idCard = <span class="keyword">new</span> IdCard();</span><br><span class="line">idCard.setCardNo(<span class="string">"11111111"</span>);</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"qqq"</span>);</span><br><span class="line"></span><br><span class="line">person.setIdCard(idCard);</span><br><span class="line"></span><br><span class="line">session.save(idCard);</span><br><span class="line">session.save(person);</span><br></pre></td></tr></table></figure>
<p>　　测试数据为，看到这个图就应该知道我们这里是用外键关系了，在person表中有一个外键字段值。</p>
<p><img src="http://img.bcoder.top/2017.05.29/14.png" alt="">
　　　　　　　　</p>
<p>　　</p>
<p>真正的测试一下单向一对一，其实也就是从person能查到idcard，但是从idcard查不到person　</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样会报异常，因为我们设置的是单向一对一，从person到Idcard，所以从idcard是查不到person。java.lang.NullPointerException</span></span><br><span class="line">IdCard idCard = (IdCard)session.get(IdCard<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(idCard.getPerson().getName());;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是这样就查得到一个人的idCard</span></span><br><span class="line">Person person = (Person)session.get(Person<span class="class">.<span class="keyword">class</span>，1)</span>;</span><br><span class="line">person.getIdCard().getCardNo();</span><br></pre></td></tr></table></figure>




<h4 id="双向一对一外键关系"><a href="#双向一对一外键关系" class="headerlink" title="双向一对一外键关系"></a>双向一对一外键关系</h4><p>双向也很简单，只要改变两个地方，就在IdCard.java和IdCard.hbm.xml中加入这种映射关系就足够了。</p>
<p>实体类图</p>
<p><img src="http://img.bcoder.top/2017.05.29/15.png" alt="">
　　　　　　　　　　　　　　　　</p>
<p>数据库关系图还是跟单向一对一外键关系一样</p>
<p><img src="http://img.bcoder.top/2017.05.29/16.png" alt="">
　　　　　　　　　　　　　　　　　　</p>
<p>IdCard.java和IdCard.hbm.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String cardNo;</span><br><span class="line">    <span class="keyword">private</span> Person person;<span class="comment">//用来存放person对象，一对一关系</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain1.IdCard"</span> <span class="attr">table</span>=<span class="string">"idcard"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 主键生成策略 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">generator</span>&gt;</span>        </span><br><span class="line">      <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 一些常规属性 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cardNo"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 要注意property-ref这个属性，很重要，关键的地方就在这里。property-ref：指定关联类的属性名，这个属性将会和本类的主键相对应。如果没有指定，会使用对方关联类的主键来跟本类的主键比较，这里要注意不是关联表中的外键字段名。如果不指定这个属性，那么 一对一默认会使用主键去做对比。相当于原本我们是可以通过本类的主键去和关联类的外键比较，然后来找到对应记录的，但是这里一对一中没有column属性，所以该方法行不通，因此就想出了这种办法，不跟外键比，也不能跟主键比(因为不是主键关系)，那么就跟关联表中的一个属性比，也就是我们这个person中的idCard属性，为什么找得到呢，因为从person能找到idcard，那么person中的idCard中就会有对应的值，我们跟该值比，也就能找到对应的person了。class：person所在的类，这个也可以不写，hibernate会自动帮我们找到</span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">property-ref</span>=<span class="string">"idCard"</span> <span class="attr">class</span>=<span class="string">"domain1.Person"</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-one</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试:这样从IdCard就能找到person了。而不是报空指针异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IdCard idCard = (IdCard)session.get(IdCard<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(idCard.getPerson().getName());</span><br></pre></td></tr></table></figure>

<p>运行发送的sql语句和结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        idcard0_.id <span class="keyword">as</span> id3_1_,</span><br><span class="line">        idcard0_.cardNo <span class="keyword">as</span> cardNo3_1_,</span><br><span class="line">        person1_.id <span class="keyword">as</span> id4_0_,</span><br><span class="line">        person1_.name <span class="keyword">as</span> name4_0_ </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        idcard idcard0_ </span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">        person person1_ </span><br><span class="line">            <span class="keyword">on</span> idcard0_.id=person1_.id </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        idcard0_.id=?</span><br><span class="line">qqq</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>　　　　　　</p>
<p>1、单向一对一主键关联、双向一对一主键关联、单向一对一外键关联、双向一对一外键关联的配置</p>
<p>2、主键关联的特点：一个表中的主键就是外键，指向另一个表中的主键，所以两张表的主键是相同的，但是有一个缺点，就是必须依赖另一张表的主键，这在有些业务逻辑上是行不通的</p>
<p>3、知道了单向一对一主键关联，那么双向一对一主键关联就非常的简单，其重点在主键id中的主键生成策略那块还有constrained属性的使用</p>
<p>4、单向一对一外键关联其实就是多对一的一个特例，其中关键的地方在unique这个属性上面</p>
<p>5、单向一对一外键关联知道后，双向一对一外键关联也非常简单，关键的地方就在<one-to-one>中property-ref的配置，注意这个的意思是配置关联类中的属性，而不是关联类中的外键字段名。</p>
<p>6、one-to-one默认是使用主键和主键进行比较来查询数据，所以其中并没有column这个属性。因为没有这个column属性，所以就外键关联中就需要用到第5点的property-ref的属性了。</p>
<h3 id="一对多关系映射"><a href="#一对多关系映射" class="headerlink" title="一对多关系映射"></a>一对多关系映射</h3><p>一对多这种关系用的很多，但是很多人对此模糊不清，一对多不也就是多对一吗，多对多中特殊的一个不也就是一对多吗，为什么还分的那么清楚？并且还是什么单向和双向的那么麻烦，其实原因很简单，就是针对不同的情况和业务需求而产生的这种说法，</p>
<p>例如：学生和班级</p>
<ul>
<li>单向一对多：一个班级对应多个学生。 也就是说，在某种业务情况下，我只需要知道从一个班级中知道有哪些学生，但是我不需要知道一个学生在哪个班级，这时候我就没必要写通过学生能查找到对应班级这个业务</li>
<li>单向多对一：多个学生对应一个班级，可以通过每个学生查找到所在的班级名称，而不能从班级中查找到有哪些学生在里面，这就是从多到一的单面考虑，也就是说，当我们的业务需求只需要通过学生能找到对应班级，而不需要通过班级知道有哪些学生的时候，就可以写这样的单向多对一的关系映射</li>
<li>双向一对多/双向多对一：这两个是一个意思，既然度双向了，说明不管从哪一方去找另一方，度可以找得到，也就无所谓一对多，还是多对一了。从这个学生和班级来讲，通过学生能知道他所在的班级，通过班级，能知道该班级下所有的学生。</li>
</ul>
<p>通过这个例子就知道了单向和双向是干嘛用的，就是根据不同的业务所规定的，如果你需要双向就写双向的映射关系，如果只需要从一方到另一方，那么就写自己所需要的，单向一对多或者单向多对一。</p>
<p>所以我们接下要讲解的就是这三种，单向一对多、单向多对一、双向一对多。</p>
<h4 id="单向多对一"><a href="#单向多对一" class="headerlink" title="单向多对一"></a>单向多对一</h4><p>多个用户属于同一个组，多个学生属于同一个班级，多个学生属于同一个宿舍，等等，很多关系是这种多对一。因为上面是拿班级和学生来举测例子，那么所有的例子我度会用这个。为了方便和你们阅读。　　</p>
<p>多个学生属于同一个班级。单向多对一　　　　<br>User和Classes类的关系图。</p>
<p><img src="http://img.bcoder.top/2017.05.29/17.png" alt=""><br>　　　　　　　　　　　　　　　<br>数据库中存在外键值关系</p>
<p><img src="http://img.bcoder.top/2017.05.29/18.png" alt=""><br>　　　　　　　　　　　　<br>通过上面的图可以看到，单向多对一就是在多的一方中加入外键，通过该外键就能够找到对应的班级，因为不需要从一端的这方去管理这种关系，所以我们如果从班级这方来看，是不知道该班级下有哪些学生的。只能从多的一方也就是学生这边找到是哪个班级。</p>
<p>那么xxx.hbm.xml如何编写呢？</p>
<p>User 需要有相应的能力，所以需要配置外键关系。many to one</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain.User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 主键生成策略 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一些常规属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">&lt;!-- 重点在这里 </span></span><br><span class="line"><span class="comment">          name：User类也就是本类中存放一方(Classes)对象的引用名称。</span></span><br><span class="line"><span class="comment">          column：数据库表中的外键名称。注意，是被外键约束的字段的名称，写这些配置文件，要时刻记得那两张数据库表的关系。</span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"classes"</span> <span class="attr">column</span>=<span class="string">"cid"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>classes 班级 不需要有那种关系，只需要配置自己的属性就行了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain.Classes"</span> <span class="attr">table</span>=<span class="string">"Classes"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cid"</span> <span class="attr">column</span>=<span class="string">"cid"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"className"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>单向多对一的关系映射就是这样简单，原理就是在数据库中多方设置外键指向一方。 然后通过映射文件来利用这个外键帮我们达到我们的目的，这里就是通过外键，找到对应的班级放入我们自己类中的classes属性中。</p>
<p>many-to-one的属性</p>
<ul>
<li>name：影射类属性的名称</li>
<li>class：非必须的，不写，hibernate会自己根据name的值去查找</li>
<li>column：关联的字段，也是非必须的，hibernate也会帮我们在查找，但是不写的话，User中的外键名称必须和Classes中的主键名称相同。也就是关联的字段名称要相同，这样才找得到</li>
<li>not-null：默认是false，就是不能为空</li>
<li>lazy:非必须，是否采用延迟加载</li>
<li>fetch：设置抓取的策略，默认是select。
　　　　　　</li>
</ul>
<p>　　　　　　</p>
<h4 id="单向一对多"><a href="#单向一对多" class="headerlink" title="单向一对多"></a>单向一对多</h4><p>说了单向多对一，现在来说说单向一对多，根据前面我们讲的，其实就是换了一个角度去想这个问题，学生和班级，现在站在班级这方去看，肯定是需要通过班级能知晓所有在这个班学习的同学的信息。　　　　</p>
<p><img src="http://img.bcoder.top/2017.05.29/19.png" alt=""></p>
<p>数据库中还是没变，不管是单向一对多还是单向多对一，永远都市通过外键来维护关系的，单向多对一：通过映射文件知道，User的外键能够查找到对应的班级。单向一对多：又是怎么来实现通过User的外键找到属于本班的所有学生的呢？这就要看xx.hbm.xml映射文件如何写了。看下去你就会知道。</p>
<p><img src="http://img.bcoder.top/2017.05.29/20.png" alt=""></p>
<p>User 不需要多方来维护关系(维护关系的意思就是不需要通过多方找到一方的信息。)所以就不在需要many-to-one了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain.User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 主键生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一些常规属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>Classes 由于是一方来维护关系，所以需要配置相关的关系。具体看下面的代码中的配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain.Classes"</span> <span class="attr">table</span>=<span class="string">"Classes"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cid"</span> <span class="attr">column</span>=<span class="string">"cid"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"className"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--关键在这里，</span></span><br><span class="line"><span class="comment">    name:set集合属性的名称</span></span><br><span class="line"><span class="comment">    key/column：这个是外键名，这个外键字段名不一定要和本类的主键字段名相同，这点要搞清楚，记住数据库表的关系，谁指向谁就不会混淆</span></span><br><span class="line"><span class="comment">    one to many/class：一对多，所映射的类名(全限定类名，直接写类名也可以，hibernate会帮我们自动写好)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"cid"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"User"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，单向一对多也是这样配置好了，单向一对多是如何找到多的信息的呢？通过映射文件可以知道，通过本类中的主键值去寻找映射类中的外键值，有匹配的就将其对象放置到set集合中来。所以说，不管是单向一对多还是单向多对一，都需要在多方加上外键，也就是说，他们的原理度是一样的，只是站的角度不一样，单向一对多站的角度在于一方，一方如何通过外键来达到自己的目的，就看自己的映射文件如何编写，单向多对一站的角度在多方，多方如何通过外键来达到自己的目的，也要看自己的映射文件的编写。</p>
<h4 id="双向一对多-双向多对一"><a href="#双向一对多-双向多对一" class="headerlink" title="双向一对多/双向多对一"></a>双向一对多/双向多对一</h4><p>不管哪种叫法都市一样的，别搞混淆了。</p>
<p>既然知道了单向一对多，和单向多对一，这个也就很简单了，就是通过双方度能够找到对方的信息。</p>
<p><img src="http://img.bcoder.top/2017.05.29/21.png" alt="">　　　　　　　　　　　　　　　　　</p>
<p>数据库关系：还是跟上面两种是一样的。</p>
<p><img src="http://img.bcoder.top/2017.05.29/22.png" alt="">　　　　　　　　</p>
<p>User.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain.User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 主键生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一些常规属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 重点在这里 </span></span><br><span class="line"><span class="comment">        name：存放一方(Classes班级)的引用。</span></span><br><span class="line"><span class="comment">        column：数据库表中的外键名称</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"classes"</span> <span class="attr">column</span>=<span class="string">"cid"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>Classes.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain.Classes"</span> <span class="attr">table</span>=<span class="string">"Classes"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cid"</span> <span class="attr">column</span>=<span class="string">"cid"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"className"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--关键在这里，</span></span><br><span class="line"><span class="comment">      name:set集合属性的名称</span></span><br><span class="line"><span class="comment">      key/column：这个是外键名，这个外键名不一定要和本类的主键字段名相同，这点要搞清楚，</span></span><br><span class="line"><span class="comment">      one to many/class：一对多，所映射的类名(全限定类名，直接写类名也可以，hibernate会帮我们自动写好)</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"cid"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"User"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>这样就做好了双向一对多的所有工作，很简单把，明白了单向一对多和单向多对一，双向的就超级简单，就是你中有我，我中有你，大家的原理度是一样，通过多方指向一方的外键，只是站的角度不一样，那么所需要做的映射文件的配置也就不一样。注意一点：数据库中的表字段是没有变化的，就是多方的外键指向一方的主键，但是在实体类中的属性会有变化，比如单向多对一中，在User中增加了一个Classes classes的变量，目的就是为了存放班级对象实例。在单向一对多中，在一方也就是Classes类中加了一个set集合用来装自己的学生。这两个属性跟表字段没什么关系，这个不要搞混淆</p>
<h3 id="多对多关系映射"><a href="#多对多关系映射" class="headerlink" title="多对多关系映射"></a>多对多关系映射</h3><h4 id="准备：难点小结"><a href="#准备：难点小结" class="headerlink" title="准备：难点小结"></a>准备：难点小结</h4><p>问题一：到这里，有很多学习者会感到困惑，因为他不知道使用hibernate是不是需要自己去创建表，还是hibernate全自动，如果需要自己创建表，那么主外键这种设置也是自己设置吗？这让人感到很困惑，现在就来解决一下这个小疑问(如果知道了的可以直接跳过看下面的多对多映射关系讲解)</p>
<p>解答：从实际开发的角度说：肯定是先创建表，并且表中自己会导入初始数据，然后在逆向生成实体类，并且各种映射关系看自己需要什么就生成什么。<br>在我们测试和学习阶段也可以如此，先创建好数据库和表还有一些初始化数据，也可以不用把数据库中各种表关系和表字段创建好，只需要将数据库手动建好，也就是说数据库中有没有表度没关系，关键是必须得有这个数据库。如果没有表，那么我们就得通过代码来创建表，比如new一个实体类，就相当于创建了一张表，如果没有表的情况下，你就直接去查询，那么肯定会报不存在表的错误，然后每个表中的字段和表之间的外键关系，度可以通过hibernate来帮我们完成，我们编写映射文件和实体类，就是来创建表之间的关系和表中的内容的。这取决于一个配置属性。</p>
<p><code>&lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;value&lt;/prop&gt;</code><br>value值可以为四种(上文提到过，为显示重要，再叙述一遍)</p>
<ul>
<li>create：表示启动的时候先drop，再create。 也就是说每次启动，会先将数据库中表给删除，然后在创建一个。开发人员测试用的比较多</li>
<li>create-drop: 也表示创建，只不过再系统关闭前执行一下drop。 每次关闭前就将表给删除掉，等用的时候在创建</li>
<li>update: 这个操作启动的时候会去检查schema是否一致，如果不一致会做scheme更新。就是检查hibernate中和数据库表中字段关系是否一致，不一致就会更新数据库</li>
<li>validate: 启动时验证现有schema与你配置的hibernate是否一致，如果不一致就抛出异常，并不做更新。</li>
</ul>
<p>总结：只要我们数据库中存在表，我们就可以对他进行操作(改造表中字段，通过外键联合其他表等度可以独立完成)，而不需要我们在去手动操作底层数据库。所以在大多数书上就是直接上操作hibernate的代码，而不关心数据库怎么样，他们的前提是数据库中有他们所操作的表就够了。</p>
<p>　　　　　　　　　　　　<br>问题二：在xxx.hbm.xml中的主键生成策略，是否需要让数据库底层主键自动生成，这个需要搞清楚，不能够混淆。当你纠结主键生成策略与数据库主键到底该不该用AUTO_INCREMENT时，那你就需要去总结一下这两者的关系了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;id name&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;</span><br><span class="line">　&lt;!-- 主键生成策略 --&gt;</span><br><span class="line">　&lt;generator class&#x3D;&quot;increment&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">&lt;&#x2F;id&gt;</span><br></pre></td></tr></table></figure>
<p>主键生成策略常用就六种:</p>
<ul>
<li>increment：hibernate管理，自动让主键自动增长，而数据库中主键就可以不用在设置AUTO_INCREMENT了。</li>
<li>identity：底层数据库管理，也就是说数据库需要自己设置主键自动增长（AUTO_INCREMENT），不设置的话，就需要自己手动设置，不太好。Mysql和sql server支持这个，但是Oracle不支持，也就是说Orable不支持底层自动增长，但是Oracle有另一种底层机制，那就是sequence</li>
<li>sequence：底层数据库管理，数据库自己来提供这个主键是多少，具体如何算我们不了解Oracle就使用这个，Mysql就不支持这个，但mysql支持identity，也就是让数据库自动增长，这两个的区别就在这里，一个底层使用AUTO_INCREMENT,一个底层使用这个序列化增长的。</li>
<li>native：hibernate不管理，让数据库底层自己选择主键如何生成，也就是说，如果是mysql，那就默认使用identity，也就是我们自己需要设置AUTO_INCREMENT，如果是Oracle，那么就默认使用sequence，让数据库底层自己设计哪个序列化增长</li>
<li>uuid：这个大家很熟悉，也就是我们不需要在数据库中主键上设置什么，每次度会给主键生成一个随机的32位字符串</li>
<li>assigned：这个很简单，就是我们需要手动自己给主键设置值，hibernate和数据库度不主动帮我们设置。</li>
</ul>
<p>就这六种，其实很好学，identity和sequence就是需要我们自己在数据库中设置自动增长或者序列化增长，increment就是hibernate帮我们管理主键。数据库底层不需要写任何东西，前提是数据库需要支持自动增长，比如Oracle就用不了这个，native也是需要我们自己在数据库中设置，但是比起identity和sequence更加灵活，更改底层数据库，这个就不需要改，uuid也很熟悉大家，assigned这个更简单，就是用来自己写主键值的嘛。　　</p>
<h4 id="多对多映射关系"><a href="#多对多映射关系" class="headerlink" title="多对多映射关系"></a>多对多映射关系</h4><p>已经清楚了一对多的关系后，那么就简单很多了，多对多其实也分单向多对多，和双向多对多，但是单向多对多比较简单，并且用的最多的就是双向多对多了，知道了双向多对多，单向多对多就非常简单，所以我们直接讲双向多对多</p>
<p>生活中有很多例子就是双向多对多的，最简单和贴近我们生活的，<br>1、学生和选课之间的关系了，学生可以选择多门课程，课程可以被多个学生选择，<br>2、在淘宝中购物，一件商品能被多个人选择，一个人能够选择多个商品<br>3、….很多这种多对多关系，就拿学生和选课这个例子来讲解。</p>
<p>要保存多对多的关系，两张表是不够的，需要增加第三张表来表示这种关系，来看下面的数据库关系图。</p>
<p><img src="http://img.bcoder.top/2017.05.29/23.png" alt=""></p>
<p>这个图意思就是用student_course这个中间表来保存student和course这两张表的关系，并且student_course是联合主键。同时也是外键，指向student的sid和Course的cid。</p>
<p>有人肯定会觉得为什么还要用第三张表，不直接使用两个外键，你指向我，我指向你这样呢，这样会暴露出一个很大的问题，如果学过数据库就应该会知道，这样的两张表相互关联，那么这两张表的关系就固定在那里了，删哪个表就不能删，这个都市小事，当你在查询一个表中数据时，会造成死循环，你查了我，我又在查你，一直重复下去。那就GG了。</p>
<p>　　　　　　　　　　　　　　　　　　　　　　</p>
<p><strong>解析:为什么需要设置联合主键和两个外键：</strong></p>
<p>student通过自己的主键在连接表中查询，因为是复合主键，所以查询到的记录有很多，而不是唯一的，这些记录中就记录了一个学生的所有课程，拿到这些记录后，由于连接表中的有course的外键，所以能够通过记录中的c_id，找到course表中对应的记录。反过来，course通过自己的主键在连接表中查询得到很多记录，由于连接表中也有student的外键，所以通过记录中的s_id也能找到student中对应的记录。所以，表的设计就是这样，需要联合主键，并且也都市外键，这些度是有用的。少一个就查不出对方了。</p>
<p>实体类和映射配置</p>
<p>Student持久化类和Student.hbm.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer sid;</span><br><span class="line">    <span class="keyword">private</span> String sname;</span><br><span class="line">    <span class="comment">//用set集合来保存选的多个课程</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Course&gt; courseSet = <span class="keyword">new</span> HashSet&lt;Course&gt;();</span><br><span class="line"></span><br><span class="line">  set、get.....  </span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;class name&#x3D;&quot;domain.Student&quot; table&#x3D;&quot;student&quot;&gt;</span><br><span class="line">    &lt;id name&#x3D;&quot;sid&quot; column&#x3D;&quot;sid&quot;&gt;</span><br><span class="line">        &lt;!-- 主键生成策略 --&gt;</span><br><span class="line">        &lt;generator class&#x3D;&quot;increment&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">    &lt;&#x2F;id&gt;</span><br><span class="line">    &lt;!-- 一些常规属性 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;sname&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 关键的地方就在这里了。一定要搞清楚两个column分别指的是什么意思 脑袋中要有哪个数据库关系图--&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!--要查询到所有的course，就需要通过连接表，所以申明连接表的名称--&gt;</span><br><span class="line">	&lt;set name&#x3D;&quot;courseSet&quot; table&#x3D;&quot;student_course&quot;&gt;</span><br><span class="line">	&lt;!-- 本实体类在连接表中的外键名称，过程我们上面分析的很清楚了，为什么需要这个呢？让hibernate知道连接表中有一个外键名为s_id的指向本实体类 --&gt;</span><br><span class="line">	    &lt;key column&#x3D;&quot;s_id&quot;&gt;&lt;&#x2F;key&gt;</span><br><span class="line">	    &lt;!-- 多对多映射关系，映射类和其映射类在连接表中的外键名称 这个的意思跟上面的一样，也是声明让hibernate知道，这样一来，hibernate就知道如何查询了--&gt;</span><br><span class="line">	    &lt;many-to-many class&#x3D;&quot;domain.Course&quot; column&#x3D;&quot;c_id&quot;&gt;&lt;&#x2F;many-to-many&gt;</span><br><span class="line">	&lt;&#x2F;set&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>

<p>Course和Course.hbm.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Course实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cid;</span><br><span class="line">    <span class="keyword">private</span> String cname;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; studentSet = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">  ...  </span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>Course.hbm.xml 有了上面的分析，这个就简单了，内容和意义跟上面的一模一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;class name&#x3D;&quot;domain.Course&quot; table&#x3D;&quot;course&quot;&gt;</span><br><span class="line">    &lt;id name&#x3D;&quot;cid&quot; column&#x3D;&quot;cid&quot;&gt;</span><br><span class="line">        &lt;!-- 主键生成策略 --&gt;</span><br><span class="line">        &lt;generator class&#x3D;&quot;increment&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">    &lt;&#x2F;id&gt;</span><br><span class="line">    &lt;!-- 一些常规属性 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;cname&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;set name&#x3D;&quot;studentSet&quot; table&#x3D;&quot;student_course&quot;&gt;</span><br><span class="line">        &lt;!-- 本类在连接表中外键的名称， --&gt;</span><br><span class="line">        &lt;key column&#x3D;&quot;c_id&quot;&gt;&lt;&#x2F;key&gt;</span><br><span class="line">　　　　　　&lt;!--多对多映射关系，映射类和其映射类在连接表中的外键名称--&gt;</span><br><span class="line">        &lt;many-to-many class&#x3D;&quot;domain.Student&quot; column&#x3D;&quot;s_id&quot;&gt;&lt;&#x2F;many-to-many&gt;</span><br><span class="line">    &lt;&#x2F;set&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>


<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Course course = <span class="keyword">new</span> Course();</span><br><span class="line">course.setCname(<span class="string">"化学"</span>);</span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setSname(<span class="string">"qqq"</span>);</span><br><span class="line"></span><br><span class="line">course.getStudentSet().add(student);</span><br><span class="line"><span class="comment">//student.getCourseSet().add(course);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">session.save(course);</span><br><span class="line">session.save(student);</span><br></pre></td></tr></table></figure>
<p>其他的就省略了，只写重要的代码。由于刚建立起来的关系，数据库中还没有任何数据，那么就添加初始数据了。这里会出现一个问题。如果把注释的这一行给放开的话，<br>报一个org.hibernate.exception.ConstraintViolationException错误，为什么会这样呢？其实从我们上面对数据库设计图的分析我们可以知道(只是那个分析是用查询来当例子，增加数据跟那个过程差不多)，<br>在course的StudentSet中添加一个学生，这个过程是怎样的呢？因为要对StudentSet进行操作，那么就会找到连接表，添加一个学生，那么就会在连接表中，添加一条course的cid对应student的sid的记录，然后如果<br>你在用student.getCourseSet().add(course)的话，又往连接表中增加了一条一模一样的记录，这个时候肯定会报错啊，因为是联合主键，两条记录一样，怎么会插的进去呢。所以就会出现违反约束异常（违反主键约束）了。</p>
<p>效果图</p>
<p><img src="http://img.bcoder.top/2017.05.29/24.png" alt="">
　　　　　　　　　　　　　　　</p>
<h3 id="反转（inverse）与级联（cascade）"><a href="#反转（inverse）与级联（cascade）" class="headerlink" title="反转（inverse）与级联（cascade）"></a>反转（inverse）与级联（cascade）</h3><h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>我为什么要把这个单独拿出来说呢？因为昨天我才发现我自己对这个外键的概念原来理解偏差了，并且很多人估计和我一样，对这个东西理解错了，现在就来说说一个什么误区。</p>
<p>1、这张表的外键是deptId把？　　2、这张表有外键吗？</p>
<p>大多数人这里说的外键，是指的一张表中被外键约束的字段名称。这是很多人从一开始就默认的，其实并不然，</p>
<p>解释:对于每张有外键约束这个约束关系的表，都会给这个外键约束关系取一个名字，从给表设置外键约束的语句中就可以得知。<br><code>CONSTRAINT 外键名 FOREIGN KEY 被外键约束修饰的字段名 REFERENCES 父表名(主键)</code></p>
<p>所以说，平常大多数人口中的外键，指的是被外键约束修饰的字段名，外键关系是有自己的名称的。这点大家需要搞清楚，虽然平常影响不大，但是到真正关键的地方，自己可能就会被这种小知识点给弄蒙圈。</p>
<h4 id="cascade-级联-关系"><a href="#cascade-级联-关系" class="headerlink" title="cascade(级联)关系"></a>cascade(级联)关系</h4><p>解释：级联，就是对一个对象进行操作的时候，会把他相关联的对象也一并进行相应的操作，相关联的对象意思是指 比如前两节学的一对多关系中，班级跟学生，Student的实体类中，存在着Classes对象的引用变量，如果保存Classes对象的引用变量有值的话，则该值就是相关联的对象，并且在对student进行save时，如果保存Classes对象的引用变量有值，那么就会将Classes对象也进行save操作， 这个就是级联的作用。</p>
<p>说大白话这个意思很难到位，举个员工和部门 双向一对多的例子把。</p>
<p>创建实验环境(这个可以自己去实现一下，练习一下关联关系的配置)</p>
<p>　　首先得对这两个表的关系图弄清楚，在接下来的所有分析中，要带着这个关系去分析，你才不会蒙圈</p>
<p><img src="http://img.bcoder.top/2017.05.29/25.png" alt="">　　　　　　　　　　　　　　</p>
<p>Staff.java 和 Staff.hbm.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line">................</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>Staff.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"oneToMany.Staff"</span> <span class="attr">table</span>=<span class="string">"staff"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	   <span class="comment">&lt;!--name:staff实体类中的dept属性，column：子表中被外键约束修饰的字段名 class：Staff相关联的Dept类--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">column</span>=<span class="string">"deptId"</span> <span class="attr">class</span>=<span class="string">"oneToMany.Dept"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">   <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Dept.java 和 Dept.hbm.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Staff&gt; staffSet = <span class="keyword">new</span> HashSet&lt;Staff&gt;();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>Dept.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"oneToMany.Dept"</span> <span class="attr">table</span>=<span class="string">"dept"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	    <span class="comment">&lt;!--key：子表被外键约束修饰的字段名--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"staffSet"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"deptId"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"oneToMany.Staff"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>配置了一个双向一对多的关联关系</p>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建新部门</span></span><br><span class="line">Dept dept = <span class="keyword">new</span> Dept();</span><br><span class="line">dept.setName(<span class="string">"er部门"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新的职员</span></span><br><span class="line">Staff staff = <span class="keyword">new</span> Staff();</span><br><span class="line">staff.setName(<span class="string">"www"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给职员中添加部门</span></span><br><span class="line">staff.setDept(dept);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给部门中添加职员</span></span><br><span class="line">dept.getStaffSet().add(staff);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存部门</span></span><br><span class="line">session.save(dept);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存员工</span></span><br><span class="line">session.save(staff);</span><br></pre></td></tr></table></figure>

<p>结果如下将两个实例保存到对应表中了。</p>
<p><img src="http://img.bcoder.top/2017.05.29/26.png" alt=""><br>　　　　　　　　　　<br>在我们什么都不清楚的时候，就会先保存部门，然后又要在保存一下员工，这样才能让两条记录进入响应的表中，如果使用了级联，那么就不需要这样写的如此麻烦那了。</p>
<p>比如我们想在保存staff时，就把dept也顺带给保存了。</p>
<p>其他不变，就在staff.hbm.xml中增加级联属性　　</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"oneToMany.Staff"</span> <span class="attr">table</span>=<span class="string">"staff"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">column</span>=<span class="string">"deptId"</span> <span class="attr">class</span>=<span class="string">"oneToMany.Dept"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>cascade=”save-update” 在相关联的属性这里设置级联，表示该实体类对象如果在save或update或者saveOrUpdate操作时，会将这个相关联的对象(前提是有这个对象，也就是引用对象变量有值)进行相应的操作，所以在测试类中就只需要写上session.save(staff); 而不在需要写session.save(dept)啦。因为有级联的存在，　　　</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Dept dept = <span class="keyword">new</span> Dept();</span><br><span class="line">dept.setName(<span class="string">"er部门"</span>);</span><br><span class="line"></span><br><span class="line">Staff staff = <span class="keyword">new</span> Staff();</span><br><span class="line">staff.setName(<span class="string">"www"</span>);</span><br><span class="line"><span class="comment">//这个就是设置相关联的对象</span></span><br><span class="line">staff.setDept(dept);</span><br><span class="line"><span class="comment">//这句话可以有可以没有，具体作用在讲解inverse的时候在说</span></span><br><span class="line">dept.getStaffSet().add(staff);</span><br><span class="line"></span><br><span class="line"><span class="comment">//session.save(dept);</span></span><br><span class="line"><span class="comment">//只需要保存staff，就会将dept也一并保存了。</span></span><br><span class="line">session.save(staff);</span><br></pre></td></tr></table></figure>


<p>结果 如我们想的那样，级联保存了dept这个对象。</p>
<p><img src="http://img.bcoder.top/2017.05.29/27.png" alt="">　　　　　　　　</p>
<p>当然，这只是在staff这一方设置级联，你也可以在dept这一方设置级联，使的只保存dept，就能将staff也保存了。这里只是把保存对象做一个例子来讲解，级联并不一定就只是级联保存还有很多别的属性，看下面总结</p>
<p>总结：　　</p>
<p>知道了级联的作用，下面来看看级联的属性</p>
<p>cascade关系有以下几种</p>
<ul>
<li>all: 所有情况下均进行关联操作，即save-update和delete。</li>
<li>none: 所有情况下均不进行关联操作。这是默认值。</li>
<li>save-update: 在执行save/update/saveOrUpdate时进行关联操作。</li>
<li>delete: 在执行delete 时进行关联操作。</li>
<li>all-delete-orphan: 当一个节点在对象图中成为孤儿节点时，删除该节点</li>
</ul>
<p>我们使用得是save-update，也就是说如果相关联的对象在表中没有记录，则会一起save，如果有，看是否发生改变，会进行updat　　　　</p>
<p>其他应该都知道，说一下这个all-delete-orphan：什么是孤儿节点，举个例子，班级和学生，一张classes表，一张student表，student表中有5个学生的数据，其5个学生都属于这个班级，也就是这5个学生中的外键字段都指向那个班级，现在删除其中一个学生(remove)，进行的数据操作仅仅是将student表中的该学生的外键字段置为null，也就是说，则个学生是没有班级的，所以称该学生为孤儿节点，我们本应该要将他完全删除的，但是结果并不如我们所想的那样，所以设置这个级联属性，就是为了删除这个孤儿节点。也就是解决这类情况。</p>
<p> cascade关系比较简单，就是这么几种，不难理解。关键的地方是理解对关联对象进行相应的操作，这个关联对象指的是谁，知道了这个，就知道了为什么在映射文件中那个位置设置级联属性了。</p>
<h4 id="inverse（反转）关系"><a href="#inverse（反转）关系" class="headerlink" title="inverse（反转）关系"></a>inverse（反转）关系</h4><p>这个是我比较难理解的一个点，一开始，因为很多人都没把他说清楚。</p>
<p>inverse的值是boolean值，也就是能设置为true或false。 如果一方的映射文件中设置为true，说明在映射关系(一对多，多对多等)中让对方来维护关系。如果为false，就自己来维护关系。默认值是true。 并且这属性只能在一端设置。比如一对多，这个一端。也就是在有set集合的这方设置。</p>
<p>维护关系：维护什么关系呢？包括两个方面</p>
<p>1、也就是维护外键的关系了，通俗点讲，就是哪一方去设置这个被外键约束的字段的值。就拿上面这个例子来说，staff和dept两张表不管进行什么操作，只要关系到了另一张表，就不可避免的要通过操作外键字段，比如，staff查询自己所属的部门，就得通过被外键约束的字段值到dept中的主键中查找，如果dept想查询自己部门中有哪些员工，就拿着自己的主键值跟staff中的外键字段做比较，找到相同的值则是属于自己部门的员工。 这个是查询操作， 现在如果是添加操作呢，staff表中添加一条记录，并且部门属于dept表中的其中一个，staff中有被外键约束修饰的字段，那是通过staff的insert语句就对这个外键字段赋值，还是让dept对象使用update语句对其赋值呢，两个都能对这个外键字段的值进行操作，谁去操作呢？如果不做设置，两个都会操作，虽然不会出现问题，但是会影响性能，因为staff操作的话，在使用insert语句就能设置外键字段的值了，但是dept也会进行对其进行操作，又使用update语句，这样一来，这个update就显的很多余。</p>
<p>2、维护级联的关系，也就是说如果如果让对方维护关系，则自己方的级联将会失效，对方设置的级联有用，如果自己维护关系，则自己方的级联会有用，但是对方设置的级联就会失效。</p>
<p>就上面的运行结果，会发送5条sql语句，前两条没关系，看后面三条。看到最后一条了吗，就是我们所说的发了一跳update语句。这就证实了我们上面所说的观点，两个表度对其维护外键关系。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        <span class="keyword">max</span>(<span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        dept</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        <span class="keyword">max</span>(<span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        staff</span><br></pre></td></tr></table></figure>
<p> 上面这两条不用管，这个是设置了主键生成策略为increment就会发送这两句。得到数据库表中最大的一个id值，才知道下一次要赋的id值给多少。</p>
<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        dept</span><br><span class="line">        (<span class="keyword">name</span>, <span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        staff</span><br><span class="line">        (<span class="keyword">name</span>, deptId, <span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?, ?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        staff </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        deptId=? </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">id</span>=?</span><br></pre></td></tr></table></figure>

<p>为了解决这种问题，使用inverse这个属性，来只让一方维护关系(维护外键值)。</p>
<p>在一的一方设置该属性,inverse=true 是默认值，也就是说让staff来维护这种关系。</p>
<p>Dept.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"oneToMany.Dept"</span> <span class="attr">table</span>=<span class="string">"dept"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	    <span class="comment">&lt;!--inverse="true"，让对方维护关系，此时这里的cascade设置没什么用，因为自身不维护关系，它也就失效了。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"staffSet"</span> <span class="attr">inverse</span>=<span class="string">"true"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"deptId"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"oneToMany.Staff"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Staff.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"oneToMany.Staff"</span> <span class="attr">table</span>=<span class="string">"staff"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">　　　　<span class="comment">&lt;!--这个级联就有用，因为是让自己这方维护关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">column</span>=<span class="string">"deptId"</span> <span class="attr">class</span>=<span class="string">"oneToMany.Dept"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：dept.getStaffSet().add(staff); 或者 staff.setDept(dept); 作用有两个，一个是让其双方度有相关联的对象，在设置级联时，能只需保存一方，另一方就级联保存了。另一个作用是这样设置了关系，会让staff或者dept这方会知道两者的关系是怎么样的，也就是能够有给外键字段赋值的能力。 因为我们设置了让staff管理，所以dept.getStaffSet().add(staff)；这句话就可以注释掉，是多余了，告诉他了该怎么设置外键字段的值，他也不会去设置，只需要让staff去设置就好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dept dept = <span class="keyword">new</span> Dept();</span><br><span class="line">dept.setName(<span class="string">"er部门"</span>);</span><br><span class="line"></span><br><span class="line">Staff staff = <span class="keyword">new</span> Staff();</span><br><span class="line">staff.setName(<span class="string">"www"</span>);</span><br><span class="line">staff.setDept(dept);</span><br><span class="line"></span><br><span class="line"><span class="comment">//dept.getStaffSet().add(staff);    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//session.save(dept);//在dept方设置了级联，但是只保存dept，staff也不会级联保存，因为这种关系dept已经不管了，dept方的级联会失效。所以需要将其注释，在staff方设置级联，保存staff就行</span></span><br><span class="line">session.save(staff);<span class="comment">//级联保存dept，并且自己会设置外键字段的值，也就是维护外键关系。</span></span><br></pre></td></tr></table></figure>

<p>看发送的SQL语句，如果猜想没错的话，这次就不会在发送update语句了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        <span class="keyword">max</span>(<span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        dept</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        <span class="keyword">max</span>(<span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        staff</span><br><span class="line"><span class="comment">------------------------------------------------------</span></span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        dept</span><br><span class="line">        (<span class="keyword">name</span>, <span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        staff</span><br><span class="line">        (<span class="keyword">name</span>, deptId, <span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?, ?)</span><br></pre></td></tr></table></figure>

<p>如果将inverse设置为false。就表明让dept来设置外键值，staff可以不用管了，</p>
<p>Dept.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"oneToMany.Dept"</span> <span class="attr">table</span>=<span class="string">"dept"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	    <span class="comment">&lt;!--inverse="false"，让自己维护关系，此时这里的cascade设置就生效了，对方的eascade失效。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"staffSet"</span> <span class="attr">inverse</span>=<span class="string">"false"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"deptId"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"oneToMany.Staff"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Staff.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"oneToMany.Staff"</span> <span class="attr">table</span>=<span class="string">"staff"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">　　　　<span class="comment">&lt;!--这个级联失效，也就是说，如果单单只保存staff，是不会级联保存dept的。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">column</span>=<span class="string">"deptId"</span> <span class="attr">class</span>=<span class="string">"oneToMany.Dept"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为有了上面的配置，看看测试的代码如何写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Dept dept = <span class="keyword">new</span> Dept();</span><br><span class="line">dept.setName(<span class="string">"er部门"</span>);</span><br><span class="line"></span><br><span class="line">Staff staff = <span class="keyword">new</span> Staff();</span><br><span class="line">staff.setName(<span class="string">"www"</span>);</span><br><span class="line"><span class="comment">//这句就可以去掉了，staff不会在管理了。 </span></span><br><span class="line"><span class="comment">//staff.setDept(dept);</span></span><br><span class="line"><span class="comment">//因为dept来维护关系，所以必须得让他知道如何去关系这种外键关系并且知道相关联对象，所以说这句话的作用正好又能让级联的作用体现出来，又能体现外键关系，</span></span><br><span class="line">dept.getStaffSet().add(staff);    </span><br><span class="line"></span><br><span class="line">session.save(dept);<span class="comment">//因为在dept方设置了save-update级联，所以只保存dept就可以了。</span></span><br><span class="line"><span class="comment">//session.save(staff);</span></span><br></pre></td></tr></table></figure>

<p>这个的结果就会有update语句，因为是dept来管理，他要管理，就必须发送update</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        <span class="keyword">max</span>(<span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        dept</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        <span class="keyword">max</span>(<span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        staff</span><br></pre></td></tr></table></figure>
<p> 上面这两条不用管，这个是设置了主键生成策略为increment就会发送这两句。得到数据库表中最大的一个id值，才知道下一次要赋的id值给多少。</p>
<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        dept</span><br><span class="line">        (<span class="keyword">name</span>, <span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        staff</span><br><span class="line">        (<span class="keyword">name</span>, deptId, <span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?, ?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        staff </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        deptId=? </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">id</span>=?</span><br></pre></td></tr></table></figure>




<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>到这里，inverse和cascade这两个的作用就已经讲解完了</p>
<ul>
<li>inverse的权限在cascade之上，意思就是cascade是否有用，还得看inverse这个属性</li>
<li>inverse的作用：在映射关系中，让其中一方去维护关系，好处就是能提高性能，不用重复维护。<ul>
<li>维护两种关系，看下控制级联关系是否有效:cascade是否有效，就得看inserve的值，如果是自己方来维护关系，那么cascade就有效，反之无效</li>
<li>控制外键关系:这个就得通过让自己拥有对方的实例引用(可能是set，也可能就是单个存储对象的变量)，这样才具备控制外键关系的能力，然后看inserve的值，</li>
</ul>
</li>
<li>inverse只能在一的一方设置，并且默认值是true，也就是说，不设置inverse时，默认是让多的一方去维护关系，这种一般是在双向、外键关系中才设置inverse的值，如果是单向的，就只有一方有维护关系的权利。</li>
<li>在以后的代码中，先要搞清楚关系，才能写出性能最好的代码。通过学习这两个属性，在测试代码中，就不必那么麻烦了，只需要考虑维护关系的一方，另一方就会自动保存了。</li>
<li>如果你对测试代码发送了多少条sql语句不清楚的话，可以往前面看看那篇讲解一级缓存和三种状态的文章，通过快照区和session作用域来分析，到底会发送多少条sql语句。</li>
</ul>
<h2 id="Hibernate检索方式"><a href="#Hibernate检索方式" class="headerlink" title="Hibernate检索方式"></a>Hibernate检索方式</h2><p>主要的检索方式有：</p>
<ol>
<li><p>唯一标识OID的检索方式</p>
<pre><code>* session.get(对象.class,OID)</code></pre></li>
<li><p>对象的导航的方式</p>
</li>
<li><p>HQL的检索方式</p>
<ul>
<li>Hibernate Query Language    – Hibernate的查询语言</li>
</ul>
</li>
<li><p>QBC的检索方式</p>
<ul>
<li>Query By Criteria    – 条件查询</li>
</ul>
</li>
<li><p>SQL检索方式</p>
<ul>
<li>本地的SQL检索<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*本地SQL检索示例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">Transaction tr = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">SQLQuery sqlQuery = session.createSQLQuery(<span class="string">"select * from cst_linkman where lkm_gender = ?"</span>);</span><br><span class="line">sqlQuery.setParameter(<span class="number">0</span>,<span class="string">"男"</span>);</span><br><span class="line">sqlQuery.addEntity(Linkman<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">List&lt;Linkman&gt; list = sqlQuery.list();</span><br><span class="line">System.out.println(list);</span><br><span class="line">tr.commit();</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="HQL检索"><a href="#HQL检索" class="headerlink" title="HQL检索"></a>HQL检索</h3><h4 id="HQL检索概述"><a href="#HQL检索概述" class="headerlink" title="HQL检索概述"></a>HQL检索概述</h4><ol>
<li>HQL的介绍</li>
</ol>
<ul>
<li>HQL(Hibernate Query Language) 是面向对象的查询语言, 它和 SQL 查询语言有些相似</li>
<li>在 Hibernate 提供的各种检索方式中, HQL 是使用最广的一种检索方式</li>
</ul>
<ol start="2">
<li>HQL与SQL的关系</li>
</ol>
<ul>
<li>HQL 查询语句是面向对象的,Hibernate负责解析HQL查询语句, 然后根据对象-关系映射文件中的映射信息, 把 HQL 查询语句翻译成相应的 SQL 语句. </li>
<li>HQL 查询语句中的主体是域模型中的类及类的属性</li>
<li>SQL 查询语句是与关系数据库绑定在一起的. SQL查询语句中的主体是数据库表及表的字段</li>
</ul>
<hr>
<p>具体应用：</p>
<ul>
<li><p>HQL基本的查询格式</p>
<ul>
<li>支持方法链的编程，即直接调用list()方法</li>
<li>简单的代码如下<ul>
<li>session.createQuery(“from Customer”).list();</li>
</ul>
</li>
</ul>
</li>
<li><p>使用别名的方式</p>
<ul>
<li>可以使用别名的方式<ul>
<li>session.createQuery(“from Customer c”).list();</li>
<li>session.createQuery(“select c from Customer c”).list();</li>
</ul>
</li>
</ul>
</li>
<li><p>排序查询</p>
<ul>
<li><p>排序查询和SQL语句中的排序的语法是一样的</p>
<ul>
<li><p>升序</p>
<ul>
<li>session.createQuery(“from Customer order by cust_id”).list();</li>
</ul>
</li>
<li><p>降序</p>
<ul>
<li>session.createQuery(“from Customer order by cust_id desc”).list();</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分页查询</p>
<ul>
<li><p>Hibernate框架提供了分页的方法，咱们可以调用方法来完成分页</p>
</li>
<li><p>两个方法如下</p>
<ul>
<li>setFirstResult(a)        – 从哪条记录开始，如果查询是从第一条开启，值是0</li>
<li>setMaxResults(b)        – 每页查询的记录条数</li>
</ul>
</li>
<li><p>演示代码如下</p>
<ul>
<li>List<LinkMan> list = session.createQuery(“from LinkMan”).setFirstResult(0).setMaxResults().list();</li>
</ul>
</li>
</ul>
</li>
<li><p>带条件的查询</p>
<ul>
<li>setParameter(“?号的位置，默认从0开始”,”参数的值”); 不用考虑参数的具体类型</li>
<li>按位置绑定参数的条件查询（指定下标值，默认从0开始）</li>
<li>按名称绑定参数的条件查询（HQL语句中的 ? 号换成 :名称 的方式）</li>
<li>例如代码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Query query = session.createQuery(<span class="string">"from Linkman where lkm_name like ? order by lkm_id desc"</span>);</span><br><span class="line">query.setFirstResult(<span class="number">0</span>).setMaxResults(<span class="number">3</span>);</span><br><span class="line">query.setParameter(<span class="number">0</span>, <span class="string">"%熊%"</span>);</span><br><span class="line">List&lt;Linkman&gt; list = query.list();</span><br><span class="line"><span class="keyword">for</span> (Linkman linkman : list) &#123;</span><br><span class="line">	System.out.println(linkman);</span><br><span class="line">&#125;</span><br><span class="line">```	</span><br><span class="line">####基本检索</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HQL：基本检索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 基本查询</span></span><br><span class="line">	<span class="comment">/*Query query = session.createQuery("from Customer");</span></span><br><span class="line"><span class="comment">	List&lt;Customer&gt; list = query.list();*/</span></span><br><span class="line">	<span class="comment">// 起别名</span></span><br><span class="line">	<span class="comment">//Query query = session.createQuery("from Customer c");</span></span><br><span class="line">	Query query = session.createQuery(<span class="string">"select c from Customer c"</span>);</span><br><span class="line">	List&lt;Customer&gt; list = query.list();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">		System.out.println(customer);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="排序检索"><a href="#排序检索" class="headerlink" title="排序检索"></a>排序检索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HQL：排序检索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 基本查询</span></span><br><span class="line">	Query query = session.createQuery(<span class="string">"from Customer order by cust_id desc"</span>);</span><br><span class="line">	List&lt;Customer&gt; list = query.list();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">		System.out.println(customer);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="条件检索"><a href="#条件检索" class="headerlink" title="条件检索"></a>条件检索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HQL：条件查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 按位置绑定参数</span></span><br><span class="line">	<span class="comment">/*Query query = session.createQuery("from Customer where cust_name = ?");</span></span><br><span class="line"><span class="comment">	// query.setString(0, "小军军");</span></span><br><span class="line"><span class="comment">	query.setParameter(0, "小军军");</span></span><br><span class="line"><span class="comment">	List&lt;Customer&gt; list = query.list();*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 按名称绑定参数</span></span><br><span class="line">	Query query = session.createQuery(<span class="string">"from Customer where cust_name = :name"</span>);</span><br><span class="line">	query.setParameter(<span class="string">"name"</span>, <span class="string">"小添添"</span>);</span><br><span class="line">	<span class="comment">/*List&lt;Customer&gt; list = query.list();</span></span><br><span class="line"><span class="comment">	for (Customer customer : list) &#123;</span></span><br><span class="line"><span class="comment">		System.out.println(customer);</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	Customer customer = (Customer) query.uniqueResult();</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">	</span><br><span class="line">	tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分页检索"><a href="#分页检索" class="headerlink" title="分页检索"></a>分页检索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  分页查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo5</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	</span><br><span class="line">	Query query = session.createQuery(<span class="string">"from LinkMan order by lkm_id desc"</span>);</span><br><span class="line">	query.setFirstResult(<span class="number">5</span>);</span><br><span class="line">	query.setMaxResults(<span class="number">5</span>);</span><br><span class="line">	List&lt;LinkMan&gt; list = query.list();</span><br><span class="line">	<span class="keyword">for</span> (LinkMan linkMan : list) &#123;</span><br><span class="line">		System.out.println(linkMan);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="统计检索"><a href="#统计检索" class="headerlink" title="统计检索"></a>统计检索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  统计查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo6</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	</span><br><span class="line">	Query query = session.createQuery(<span class="string">"select count(*) from Customer"</span>);</span><br><span class="line">	Long num = (Long) query.uniqueResult();</span><br><span class="line">	System.out.println(num);</span><br><span class="line">	</span><br><span class="line">	tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="投影检索"><a href="#投影检索" class="headerlink" title="投影检索"></a>投影检索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 投影查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo7</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	<span class="comment">// 投影查询一列</span></span><br><span class="line">	<span class="comment">/*List&lt;String&gt; list = session.createQuery("select cust_name from Customer").list();</span></span><br><span class="line"><span class="comment">	for (String string : list) &#123;</span></span><br><span class="line"><span class="comment">		System.out.println(string);</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="comment">// 投影查询多列:</span></span><br><span class="line">	<span class="comment">/*List&lt;Object[]&gt; list = session.createQuery("select cust_id,cust_name from Customer").list();</span></span><br><span class="line"><span class="comment">	for (Object[] objects : list) &#123;</span></span><br><span class="line"><span class="comment">		System.out.println(Arrays.toString(objects));</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 投影的构造的方式查询:</span></span><br><span class="line">	List&lt;Customer&gt; list = session.createQuery(<span class="string">"select new Customer(cust_id,cust_name) from Customer"</span>).list();</span><br><span class="line">	<span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">		System.out.println(customer);</span><br><span class="line">	&#125;</span><br><span class="line">	tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="QBC检索"><a href="#QBC检索" class="headerlink" title="QBC检索"></a>QBC检索</h3><h4 id="基本检索"><a href="#基本检索" class="headerlink" title="基本检索"></a>基本检索</h4><p>简单查询，使用的是Criteria接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Customer&gt; list = session.createCriteria(Customer<span class="class">.<span class="keyword">class</span>).<span class="title">list</span>()</span>;</span><br><span class="line"><span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">&#125;</span><br><span class="line">```		</span><br><span class="line">```java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	<span class="comment">// 简单查询:</span></span><br><span class="line">	Criteria criteria = session.createCriteria(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	List&lt;Customer&gt; list = criteria.list();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">		System.out.println(customer);</span><br><span class="line">	&#125;</span><br><span class="line">	tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="条件检索-1"><a href="#条件检索-1" class="headerlink" title="条件检索"></a>条件检索</h4><p>条件查询（Criterion是查询条件的接口，Restrictions类是Hibernate框架提供的工具类，使用该工具类来设置查询条件）</p>
<ul>
<li>条件查询使用Criteria接口的add方法，用来传入条件。</li>
<li>使用Restrictions的添加条件的方法，来添加条件，例如：<blockquote>
</blockquote>
<ul>
<li>Restrictions.eq            – 相等</li>
<li>Restrictions.gt            – 大于号</li>
<li>Restrictions.ge            – 大于等于</li>
<li>Restrictions.lt            – 小于</li>
<li>Restrictions.le            – 小于等于</li>
<li>Restrictions.between        – 在之间</li>
<li>Restrictions.like            – 模糊查询</li>
<li>Restrictions.in            – 范围</li>
<li>Restrictions.and            – 并且</li>
<li>Restrictions.or            – 或者</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 条件查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	<span class="comment">// 条件查询:</span></span><br><span class="line">	Criteria criteria = session.createCriteria(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="comment">// 设置条件:</span></span><br><span class="line">	<span class="comment">// criteria.add(Restrictions.eq("cust_name", "小军军"));</span></span><br><span class="line">	criteria.add(Restrictions.like(<span class="string">"cust_name"</span>, <span class="string">"%小%"</span>));</span><br><span class="line">	criteria.add(Restrictions.gt(<span class="string">"cust_id"</span>, <span class="number">1l</span>));</span><br><span class="line">	</span><br><span class="line">	List&lt;Customer&gt; list = criteria.list();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">		System.out.println(customer);</span><br><span class="line">	&#125;</span><br><span class="line">	tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分页检索-1"><a href="#分页检索-1" class="headerlink" title="分页检索"></a>分页检索</h4><ul>
<li>QBC的分页查询也是使用两个方法<pre><code>* setFirstResult();
* setMaxResults();</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	<span class="comment">// 条件查询:</span></span><br><span class="line">	Criteria criteria = session.createCriteria(LinkMan<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="comment">// 设置分页查询:</span></span><br><span class="line">	criteria.setFirstResult(<span class="number">5</span>);</span><br><span class="line">	criteria.setMaxResults(<span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">	List&lt;LinkMan&gt; list = criteria.list();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LinkMan linkMan : list) &#123;</span><br><span class="line">		System.out.println(linkMan);</span><br><span class="line">	&#125;</span><br><span class="line">	tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="排序检索-1"><a href="#排序检索-1" class="headerlink" title="排序检索"></a>排序检索</h4><p>需要使用addOrder()的方法来设置参数，参数使用org.hibernate.criterion.Order对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 排序查询:</span></span><br><span class="line">	Criteria criteria = session.createCriteria(LinkMan<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	criteria.addOrder(Order.desc(<span class="string">"lkm_id"</span>));</span><br><span class="line">	</span><br><span class="line">	List&lt;LinkMan&gt; list = criteria.list();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LinkMan linkMan : list) &#123;</span><br><span class="line">		System.out.println(linkMan);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	tx.commit();		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="统计检索-1"><a href="#统计检索-1" class="headerlink" title="统计检索"></a>统计检索</h4><p>聚合函数查询（Projection的聚合函数的接口，而Projections是Hibernate提供的工具类，使用该工具类设置聚合函数查询）<br>        * 使用QBC的聚合函数查询，需要使用criteria.setProjection()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 统计查询:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	</span><br><span class="line">	Criteria criteria = session.createCriteria(LinkMan<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	criteria.setProjection(Projections.rowCount());</span><br><span class="line">	Long count = (Long) criteria.uniqueResult();</span><br><span class="line">	</span><br><span class="line">	System.out.println(count);</span><br><span class="line">	tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="离线条件检索"><a href="#离线条件检索" class="headerlink" title="离线条件检索"></a>离线条件检索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 离线条件查询:DetachedCriteria(SSH整合经常使用.).</span></span><br><span class="line"><span class="comment"> * * 可以脱离session设置参数.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo6</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 获得一个离线条件查询的对象</span></span><br><span class="line">	DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	detachedCriteria.add(Restrictions.eq(<span class="string">"cust_name"</span>,<span class="string">"小童童"</span>));</span><br><span class="line">	</span><br><span class="line">	Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line">	</span><br><span class="line">	List&lt;Customer&gt; list = detachedCriteria.getExecutableCriteria(session).list();<span class="comment">// 离线条件查询对象与session绑定.</span></span><br><span class="line">	<span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">		System.out.println(customer);</span><br><span class="line">	&#125;</span><br><span class="line">	tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="多表查询基础"><a href="#多表查询基础" class="headerlink" title="多表查询基础:"></a>多表查询基础:</h4><ul>
<li><p>SQL连接查询:</p>
<ul>
<li><p>交叉连接:</p>
<ul>
<li>select * from A,B;</li>
</ul>
</li>
<li><p>内连接</p>
<ul>
<li>隐式内连接<ul>
<li>select * from A ,B where A.id = B.id;</li>
</ul>
</li>
<li>显示内连接<ul>
<li>select * from A inner join B on A.id = B.id;</li>
<li>select * from A join B on A.id = B.id;</li>
</ul>
</li>
</ul>
</li>
<li><p>外连接</p>
<ul>
<li><p>左外连接</p>
<ul>
<li>select * from A left outer join B on A.id = B.id;</li>
<li>select * from A left join B on A.id = B.id;</li>
</ul>
</li>
<li><p>右外连接</p>
<ul>
<li>select * from A right outer join B on A.id = B.id;</li>
<li>select * from A right join B on A.id = B.id;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HQL连接查询:</p>
<ul>
<li><p>交叉连接:</p>
</li>
<li><p>内连接:</p>
<ul>
<li>隐式内连接</li>
<li>显示内连接</li>
<li>迫切内连接 </li>
</ul>
</li>
<li><p>外连接：</p>
<ul>
<li>左外连接</li>
<li>迫切左外连接</li>
<li>右外连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="HQL连接查询"><a href="#HQL连接查询" class="headerlink" title="HQL连接查询"></a>HQL连接查询</h4><p>多表的查询进来使用HQL语句进行查询，HQL语句和SQL语句的查询语法比较类似。</p>
<ul>
<li><p>内连接查询</p>
<ul>
<li>显示内连接<ul>
<li>select * from customers c inner join orders o on c.cid = o.cno;</li>
</ul>
</li>
<li>隐式内连接<ul>
<li>select * from customers c,orders o where c.cid = o.cno;</li>
</ul>
</li>
</ul>
</li>
<li><p>外连接查询</p>
<ul>
<li>左外连接<ul>
<li>select * from customers c left join orders o on c.cid = o.cno;</li>
</ul>
</li>
<li>右外连接<ul>
<li>select * from customers c right join orders o on c.cid = o.cno;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>HQL的多表查询</p>
<ul>
<li>迫切和非迫切：<pre><code>* 非迫切返回结果是Object[]
* 迫切连接返回的结果是对象，把客户的信息封装到客户的对象中，把订单的信息封装到客户的Set集合中。</code></pre></li>
</ul>
<p>内连接查询</p>
<ul>
<li>内连接使用 inner join ，默认返回的是Object数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">Transaction tr = session.beginTransaction();</span><br><span class="line">List&lt;Object[]&gt; list = session.createQuery(<span class="string">"from Customer c inner join c.linkmans"</span>).list();</span><br><span class="line"><span class="keyword">for</span> (Object[] objects : list) &#123;</span><br><span class="line">	System.out.println(Arrays.toString(objects));</span><br><span class="line">&#125;</span><br><span class="line">tr.commit();</span><br></pre></td></tr></table></figure>
<ul>
<li>迫切内连接:inner join fetch ，返回的是实体对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">Transaction tr = session.beginTransaction();</span><br><span class="line">List&lt;Customer&gt; list = session.createQuery(<span class="string">"from Customer c inner join fetch c.linkmans"</span>).list();</span><br><span class="line">Set&lt;Customer&gt; set = <span class="keyword">new</span> HashSet&lt;Customer&gt;(list);</span><br><span class="line"><span class="keyword">for</span> (Customer customer : set) &#123;</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">&#125;</span><br><span class="line">tr.commit();</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">左外连接查询</span><br><span class="line"></span><br><span class="line">* 左外连接:	封装成List&lt;Object[]&gt;</span><br><span class="line">		</span><br><span class="line">* 迫切左外连接</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">Transaction tr = session.beginTransaction();</span><br><span class="line">List&lt;Customer&gt; list = session.createQuery(<span class="string">"from Customer c left join fetch c.linkmans"</span>).list();</span><br><span class="line">Set&lt;Customer&gt; set = <span class="keyword">new</span> HashSet&lt;Customer&gt;(list);</span><br><span class="line"><span class="keyword">for</span> (Customer customer : set) &#123;</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">&#125;</span><br><span class="line">tr.commit();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Hibernate查询策略"><a href="#Hibernate查询策略" class="headerlink" title="Hibernate查询策略"></a>Hibernate查询策略</h2><p><strong>延迟加载</strong></p>
<ol>
<li>延迟加载先获取到代理对象，当真正使用到该对象中的属性的时候，才会发送SQL语句，是Hibernate框架提升性能的方式</li>
<li>类级别的延迟加载</li>
</ol>
<ul>
<li>Session对象的load方法默认就是延迟加载</li>
<li>Customer c = session.load(Customer.class, 1L);没有发送SQL语句，当使用该对象的属性时，才发送SQL语句<ul>
<li>使类级别的延迟加载失效<ul>
<li>在<class>标签上配置lazy=”false”</li>
<li>Hibernate.initialize(Object proxy);</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>关联级别的延迟加载（查询某个客户，当查看该客户下的所有联系人是是否是延迟加载）</li>
</ol>
<ul>
<li>默认是延迟加载<pre><code class="java">Session session = HibernateUtils.getCurrentSession();
Transaction tr = session.beginTransaction();
Customer c = session.get(Customer<span class="class">.<span class="keyword">class</span>, 1<span class="title">L</span>)</span>;
System.out.println(<span class="string">"============="</span>);
System.out.println(c.getLinkmans().size());
tr.commit();</code></pre>
</li>
</ul>
<hr>
<p><strong>查询策略</strong></p>
<ol>
<li><p>查询策略：使用Hibernate查询一个对象的时候，查询其关联对象.应该如何查询.是Hibernate的一种优化手段!!!    </p>
</li>
<li><p>Hibernate框架的检索策略解决的问题</p>
<ul>
<li><p>查询的时机<br>  Customer c1 = (Customer) session.get(Customer.class, 1);<br>  System.out.println(c1.getLinkmans().size());</p>
<ul>
<li>lazy属性解决查询的时机的问题，需要配置是否采用延迟加载！！</li>
</ul>
</li>
<li><p>查询的语句形式<br>  List<Customer> list = session.createQuery(“from Customer”).list();<br>  for(Customer c : list){</p>
<pre><code>System.out.println(c.getLinkmans());</code></pre><p>  }</p>
<ul>
<li>fetch属性就可以解决查询语句的形式的问题！！</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>在set标签上配置策略</strong></p>
<ol>
<li><p>在<set>标签上使用fetch和lazy属性</p>
<ul>
<li><p>fetch的取值                – 控制SQL语句生成的格式</p>
<ul>
<li>select                – 默认值.发送查询语句</li>
<li>join                    – 连接查询.发送的是一条迫切左外连接!!!配置了join.lazy就失效了</li>
<li>subselect                – 子查询.发送一条子查询查询其关联对象.(需要使用list()方法进行测试)</li>
</ul>
</li>
<li><p>lazy的取值                – 查找关联对象的时候是否采用延迟!</p>
<ul>
<li>true                    – 默认.延迟</li>
<li>false                    – 不延迟</li>
<li>extra                    – 及其懒惰</li>
</ul>
</li>
</ul>
</li>
<li><p>set标签上的默认值是fetch=”select”和lazy=”true”</p>
</li>
<li><p>总结：Hibernate框架都采用了默认值，开发中基本上使用的都是默认值。特殊的情况。</p>
</li>
</ol>
<hr>
<p><strong>在man-to-one标签上配置策略</strong></p>
<ol>
<li><p>在<many-to-one>标签上使用fetch和lazy属性</p>
<ul>
<li><p>fetch的取值        – 控制SQL的格式.</p>
<ul>
<li>select        – 默认。发送基本select语句查询</li>
<li>join            – 发送迫切左外连接查询</li>
</ul>
</li>
<li><p>lazy的取值        – 控制加载关联对象是否采用延迟.</p>
<ul>
<li>false            – 不采用延迟加载.</li>
<li>proxy            – 默认值.代理.现在是否采用延迟.<ul>
<li>由另一端的<class>上的lazy确定.如果这端的class上的lazy=”true”.proxy的值就是true(延迟加载).</li>
<li>如果class上lazy=”false”.proxy的值就是false(不采用延迟.)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在<many-to-one>标签上的默认值是fetch=”select”和proxy</p>
</li>
</ol>
<h2 id="Hibernate事务处理"><a href="#Hibernate事务处理" class="headerlink" title="Hibernate事务处理"></a>Hibernate事务处理</h2><h3 id="事务相关的概念"><a href="#事务相关的概念" class="headerlink" title="事务相关的概念"></a>事务相关的概念</h3><ol>
<li><p>什么是事务</p>
<ul>
<li>事务就是逻辑上的一组操作，组成事务的各个执行单元，操作要么全都成功，要么全都失败.</li>
<li>转账的例子：冠希给美美转钱，扣钱，加钱。两个操作组成了一个事情！</li>
</ul>
</li>
<li><p>事务的特性</p>
<ul>
<li>原子性    – 事务不可分割.</li>
<li>一致性    – 事务执行的前后数据的完整性保持一致.</li>
<li>隔离性    – 一个事务执行的过程中,不应该受到其他的事务的干扰.</li>
<li>持久性    – 事务一旦提交,数据就永久保持到数据库中.</li>
</ul>
</li>
<li><p>如果不考虑隔离性:引发一些读的问题</p>
<ul>
<li>脏读            – 一个事务读到了另一个事务未提交的数据.</li>
<li>不可重复读    – 一个事务读到了另一个事务已经提交的update数据,导致多次查询结果不一致.</li>
<li>虚读            – 一个事务读到了另一个事务已经提交的insert数据,导致多次查询结构不一致.</li>
</ul>
</li>
<li><p>通过设置数据库的隔离级别来解决上述读的问题</p>
<ul>
<li>未提交读:以上的读的问题都有可能发生.</li>
<li>已提交读:避免脏读,但是不可重复读，虚读都有可能发生.</li>
<li>可重复读:避免脏读，不可重复读.但是虚读是有可能发生.</li>
<li>串行化:以上读的情况都可以避免.</li>
</ul>
</li>
<li><p>如果想在Hibernate的框架中来设置隔离级别，需要在hibernate.cfg.xml的配置文件中通过标签来配置</p>
<ul>
<li>通过：hibernate.connection.isolation = 4 来配置</li>
<li>取值<ul>
<li>1—Read uncommitted isolation</li>
<li>2—Read committed isolation</li>
<li>4—Repeatable read isolation</li>
<li>8—Serializable isolation</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="丢失更新问题"><a href="#丢失更新问题" class="headerlink" title="丢失更新问题"></a>丢失更新问题</h3><ol>
<li><p>如果不考虑隔离性，也会产生写入数据的问题，这一类的问题叫丢失更新的问题。</p>
</li>
<li><p>例如：两个事务同时对某一条记录做修改，就会引发丢失更新的问题。</p>
<ul>
<li>A事务和B事务同时获取到一条数据，同时再做修改</li>
<li>如果A事务修改完成后，提交了事务</li>
<li>B事务修改完成后，不管是提交还是回滚，如果不做处理，都会对数据产生影响</li>
</ul>
</li>
<li><p>解决方案有两种</p>
<ul>
<li><p>悲观锁</p>
<ul>
<li>采用的是数据库提供的一种锁机制，如果采用做了这种机制，在SQL语句的后面添加 for update 子句<ul>
<li>当A事务在操作该条记录时，会把该条记录锁起来，其他事务是不能操作这条记录的。</li>
<li>只有当A事务提交后，锁释放了，其他事务才能操作该条记录</li>
</ul>
</li>
</ul>
</li>
<li><p>乐观锁</p>
<ul>
<li>采用版本号的机制来解决的。会给表结构添加一个字段version=0，默认值是0<ul>
<li>当A事务在操作完该条记录，提交事务时，会先检查版本号，如果发生版本号的值相同时，才可以提交事务。同时会更新版本号version=1.</li>
<li>当B事务操作完该条记录时，提交事务时，会先检查版本号，如果发现版本不同时，程序会出现错误。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用Hibernate框架解决丢失更新的问题</p>
<ul>
<li><p>悲观锁</p>
<ul>
<li>使用session.get(Customer.class, 1,LockMode.UPGRADE); 方法</li>
</ul>
</li>
<li><p>乐观锁</p>
<ul>
<li>1.在对应的JavaBean中添加一个属性，名称可以是任意的。例如：private Integer version; 提供get和set方法</li>
<li>2.在映射的配置文件中，提供<version name="version"/>标签即可。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="绑定本地的Session"><a href="#绑定本地的Session" class="headerlink" title="绑定本地的Session"></a>绑定本地的Session</h3><ol>
<li><p>之前在JavaWEB的事务的时候，需要在业务层使用Connection来开启事务，</p>
<ul>
<li>一种是通过参数的方式传递下去</li>
<li>另一种是把Connection绑定到ThreadLocal对象中</li>
</ul>
</li>
<li><p>现在的Hibernate框架中，使用session对象开启事务，所以需要来传递session对象，框架提供了ThreadLocal的方式</p>
<ul>
<li><p>需要在hibernate.cfg.xml的配置文件中提供配置</p>
<ul>
<li><code>&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;</code></li>
</ul>
</li>
<li><p>重新HibernateUtil的工具类，使用SessionFactory的getCurrentSession()方法，获取当前的Session对象。并且该Session对象不用手动关闭，线程结束了，会自动关闭。<br>  `public static Session getCurrentSession(){</p>
<pre><code>return factory.getCurrentSession();</code></pre><p>  }`</p>
</li>
<li><p>注意：想使用getCurrentSession()方法，必须要先配置才能使用</p>
</li>
</ul>
</li>
</ol>
<h2 id="Hibernate-二级缓存"><a href="#Hibernate-二级缓存" class="headerlink" title="Hibernate 二级缓存"></a>Hibernate 二级缓存</h2><p>缓存：缓存是什么，解决什么问题？ </p>
<p>位于速度相差较大的两种硬件/软件之间的，用于协调两者数据传输速度差异的结构，均可称之为缓存Cache。缓存目的：让数据更接近于应用程序，协调速度不匹配，使访问速度更快。 </p>
<p>缓存的范围分为3类: </p>
<p>1.事务范围（单Session即一级缓存）<br>   事务范围的缓存只能被当前事务访问,每个事务都有各自的缓存,缓存内的数据通常采用相互关联的对象形式.缓存的生命周期依赖于事务的生命周期,只有当事务结束时,缓存的生命周期才会结束.事务范围的缓存使用内存作为存储介质,一级缓存就属于事务范围. </p>
<p>2.应用范围（单SessionFactory即二级缓存）<br>   应用程序的缓存可以被应用范围内的所有事务共享访问.缓存的生命周期依赖于应用的生命周期,只有当应用结束时,缓存的生命周期才会结束.应用范围的缓存可以使用内存或硬盘作为存储介质,二级缓存就属于应用范围. </p>
<p>3.集群范围（多SessionFactory）<br>   在集群环境中,缓存被一个机器或多个机器的进程共享,缓存中的数据被复制到集群环境中的每个进程节点,进程间通过远程通信来保证缓存中的数据的一致,缓存中的数据通常采用对象的松散数据形式.</p>
<p>二级缓存如何工作的？</p>
<p>Hibernate的二级缓存同一级缓存一样，也是针对对象ID来进行缓存。所以说，二级缓存的作用范围是针对根据ID获得对象的查询。 </p>
<ul>
<li>在执行各种条件查询时，如果所获得的结果集为实体对象的集合，那么就会把所有的数据对象根据ID放入到二级缓存中。 </li>
<li>当Hibernate根据ID访问数据对象的时候，首先会从Session一级缓存中查找，如果查不到并且配置了二级缓存，那么会从二级缓存中查找，如果还查不到，就会查询数据库，把结果按照ID放入到缓存中。 </li>
<li>删除、更新、增加数据的时候，同时更新缓存。 </li>
</ul>
<p>与Hibernate一级缓存Session范围相对的是SessionFactory范围的二级缓存，SessionFactory也提供了相应的缓存机制。SessionFactory缓存可以依据功能和目的的不同而划分为内置缓存和外置缓存。 </p>
<p>SessionFactory的内置缓存中存放了映射元数据和预定义SQL语句，映射元数据是映射文件中数据的副本，而预定义SQL语句是在Hibernate初始化阶段根据映射元数据推导出来的。SessionFactory的内置缓存是只读的，应用程序不能修改缓存中的映射元数据和预定义SQL语句，因此SessionFactory不需要进行内置缓存与映射文件的同步。 </p>
<p>SessionFactory的外置缓存是一个可配置的插件。在默认情况下，SessionFactory不会启用这个插件。外置缓存的数据是数据库数据的副本，外置缓存的介质可以是内存或者硬盘。SessionFactory的外置缓存也被称为Hibernate的二级缓存。 </p>
<p>Hibernate的二级缓存的实现原理与一级缓存是一样的，也是通过以ID为key的Map来实现对对象的缓存。 </p>
<p>二级缓存是缓存实体对象的，由于Hibernate的二级缓存是作用在SessionFactory范围内的，因而它比一级缓存的范围更广，可以被所有的Session对象所共享。 </p>
<p>在通常情况下会将具有以下特征的数据放入到二级缓存中： </p>
<ul>
<li>很少被修改的数据。 </li>
<li>不是很重要的数据，允许出现偶尔并发的数据。 </li>
<li>不会被并发访问的数据。 </li>
<li>常量数据。 </li>
<li>不会被第三方修改的数据 </li>
</ul>
<p>而对于具有以下特征的数据则不适合放在二级缓存中： </p>
<ul>
<li>经常被修改的数据。 </li>
<li>财务数据，绝对不允许出现并发。 </li>
<li>与其他应用共享的数据。 </li>
</ul>
<p>在这里特别要注意的是对放入缓存中的数据不能有第三方的应用对数据进行更改（其中也包括在自己程序中使用其他方式进行数据的修改，例如，JDBC），因为那样Hibernate将不会知道数据已经被修改，也就无法保证缓存中的数据与数据库中数据的一致性。 </p>
<p>常见的缓存组件<br>在默认情况下，Hibernate会使用EHCache作为二级缓存组件。但是，可以通过设置hibernate.cache.provider_class属性，指定其他的缓存策略，该缓存策略必须实现org.hibernate.cache.CacheProvider接口。<br>通过实现org.hibernate.cache.CacheProvider接口可以提供对不同二级缓存组件的支持，此接口充当缓存插件与Hibernate之间的适配器。 </p>
<table>
<thead>
<tr>
<th>组件</th>
<th align="right">Provider类</th>
<th align="center">类型</th>
<th align="right">集群</th>
<th align="center">查询缓存</th>
</tr>
</thead>
<tbody><tr>
<td>Hashtable</td>
<td align="right">org.hibernate.cache.HashtableCacheProvider</td>
<td align="center">内存</td>
<td align="right">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td>EHCache</td>
<td align="right">org.hibernate.cache.EhCacheProvider</td>
<td align="center">内存，硬盘</td>
<td align="right">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td>OSCache</td>
<td align="right">org.hibernate.cache.OSCacheProvider</td>
<td align="center">内存，硬盘</td>
<td align="right">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td>SwarmCache</td>
<td align="right">org.hibernate.cache.SwarmCacheProvider</td>
<td align="center">集群</td>
<td align="right">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td>JBoss TreeCache</td>
<td align="right">org.hibernate.cache.TreeCacheProvider</td>
<td align="center">集群</td>
<td align="right">支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<blockquote>
<p>参考资料</p>
</blockquote>
<ul>
<li><a href="https://www.w3cschool.cn" target="_blank" rel="noopener">https://www.w3cschool.cn</a></li>
<li><a href="http://my.csdn.net/runming56" target="_blank" rel="noopener">http://my.csdn.net/runming56</a></li>
<li><a href="http://www.cnblogs.com/whgk/" target="_blank" rel="noopener">http://www.cnblogs.com/whgk/</a></li>
</ul>

          
            <br>
            
  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=https://www.bcoder.top/2017/05/29/Hibernate%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/>https://www.bcoder.top/2017/05/29/Hibernate%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-01-21T18:44:03+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2020-01-21 18:44:03</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/J2EE/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>J2EE</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/SSH/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>SSH</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/ORM/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>ORM</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Hibernate/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Hibernate</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/jdbc/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>jdbc</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.bcoder.top/2017/05/29/Hibernate%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/&title=Hibernate回顾总结 - zln's blog&summary=Hibernate概述
Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。 Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://www.bcoder.top/2017/05/29/Hibernate%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/&title=Hibernate回顾总结 - zln's blog&summary=Hibernate概述
Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。 Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://www.bcoder.top/2017/05/29/Hibernate%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/&title=Hibernate回顾总结 - zln's blog&summary=Hibernate概述
Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。 Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2017/05/29/Hibernate-openSession%E4%B8%8EgetCurrentSession%E7%9A%84%E5%8C%BA%E5%88%AB/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>Hibernate:openSession与getCurrentSession的区别</p>
                <p class='content'>1、openSession 每一次获得的是一个全新的session对象，而getCurrentSession获得的是与当前线程绑定的session对象


1234567891011121314...</p>
              </a>
            
            
              <a class='next' href='/2017/05/28/spring%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/'>
                <p class='title'>Spring回顾总结<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>Spring 概念Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-spinner fa-spin fa-fw"></i>
          </div>
        </section>
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'Hibernate回顾总结',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate概述"><span class="toc-number">1.</span> <span class="toc-text">Hibernate概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是ORM（对象关系映射）"><span class="toc-number">1.1.</span> <span class="toc-text">什么是ORM（对象关系映射）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hibernate优点"><span class="toc-number">1.2.</span> <span class="toc-text">Hibernate优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hibernate知识体系"><span class="toc-number">1.3.</span> <span class="toc-text">Hibernate知识体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hibernate架构图"><span class="toc-number">1.4.</span> <span class="toc-text">Hibernate架构图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate-入门程序"><span class="toc-number">2.</span> <span class="toc-text">Hibernate 入门程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate配置文件之映射配置文件"><span class="toc-number">3.</span> <span class="toc-text">Hibernate配置文件之映射配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hibernate-mapping标签"><span class="toc-number">3.1.</span> <span class="toc-text">hibernate-mapping标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class标签"><span class="toc-number">3.2.</span> <span class="toc-text">class标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id标签"><span class="toc-number">3.3.</span> <span class="toc-text">id标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#generator主键生成"><span class="toc-number">3.4.</span> <span class="toc-text">generator主键生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#property标签"><span class="toc-number">3.5.</span> <span class="toc-text">property标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate配置文件之核心配置文件"><span class="toc-number">4.</span> <span class="toc-text">Hibernate配置文件之核心配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate核心API"><span class="toc-number">5.</span> <span class="toc-text">Hibernate核心API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Configuration类"><span class="toc-number">5.1.</span> <span class="toc-text">Configuration类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SessionFactory类"><span class="toc-number">5.2.</span> <span class="toc-text">SessionFactory类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session接口"><span class="toc-number">5.3.</span> <span class="toc-text">Session接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transaction接口"><span class="toc-number">5.4.</span> <span class="toc-text">Transaction接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久化对象的状态"><span class="toc-number">6.</span> <span class="toc-text">持久化对象的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#持久化对象简介"><span class="toc-number">6.1.</span> <span class="toc-text">持久化对象简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种状态的转化"><span class="toc-number">6.2.</span> <span class="toc-text">三种状态的转化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate一级缓存"><span class="toc-number">7.</span> <span class="toc-text">Hibernate一级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一级缓存概述"><span class="toc-number">7.1.</span> <span class="toc-text">一级缓存概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制一级缓存"><span class="toc-number">7.2.</span> <span class="toc-text">控制一级缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一级缓存的快照机制"><span class="toc-number">7.3.</span> <span class="toc-text">一级缓存的快照机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate关联关系映射："><span class="toc-number">8.</span> <span class="toc-text">Hibernate关联关系映射：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一对一关系映射"><span class="toc-number">8.1.</span> <span class="toc-text">一对一关系映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单向一对一主键关联"><span class="toc-number">8.1.1.</span> <span class="toc-text">单向一对一主键关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双向一对一主键关联"><span class="toc-number">8.1.2.</span> <span class="toc-text">双向一对一主键关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单向一对一外键关联"><span class="toc-number">8.1.3.</span> <span class="toc-text">单向一对一外键关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双向一对一外键关系"><span class="toc-number">8.1.4.</span> <span class="toc-text">双向一对一外键关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">8.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一对多关系映射"><span class="toc-number">8.2.</span> <span class="toc-text">一对多关系映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单向多对一"><span class="toc-number">8.2.1.</span> <span class="toc-text">单向多对一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单向一对多"><span class="toc-number">8.2.2.</span> <span class="toc-text">单向一对多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双向一对多-双向多对一"><span class="toc-number">8.2.3.</span> <span class="toc-text">双向一对多&#x2F;双向多对一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结-1"><span class="toc-number">8.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多对多关系映射"><span class="toc-number">8.3.</span> <span class="toc-text">多对多关系映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#准备：难点小结"><span class="toc-number">8.3.1.</span> <span class="toc-text">准备：难点小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多对多映射关系"><span class="toc-number">8.3.2.</span> <span class="toc-text">多对多映射关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反转（inverse）与级联（cascade）"><span class="toc-number">8.4.</span> <span class="toc-text">反转（inverse）与级联（cascade）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#外键"><span class="toc-number">8.4.1.</span> <span class="toc-text">外键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cascade-级联-关系"><span class="toc-number">8.4.2.</span> <span class="toc-text">cascade(级联)关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inverse（反转）关系"><span class="toc-number">8.4.3.</span> <span class="toc-text">inverse（反转）关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结-2"><span class="toc-number">8.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate检索方式"><span class="toc-number">9.</span> <span class="toc-text">Hibernate检索方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HQL检索"><span class="toc-number">9.1.</span> <span class="toc-text">HQL检索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HQL检索概述"><span class="toc-number">9.1.1.</span> <span class="toc-text">HQL检索概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#排序检索"><span class="toc-number">9.1.2.</span> <span class="toc-text">排序检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#条件检索"><span class="toc-number">9.1.3.</span> <span class="toc-text">条件检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分页检索"><span class="toc-number">9.1.4.</span> <span class="toc-text">分页检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#统计检索"><span class="toc-number">9.1.5.</span> <span class="toc-text">统计检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#投影检索"><span class="toc-number">9.1.6.</span> <span class="toc-text">投影检索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QBC检索"><span class="toc-number">9.2.</span> <span class="toc-text">QBC检索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本检索"><span class="toc-number">9.2.1.</span> <span class="toc-text">基本检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#条件检索-1"><span class="toc-number">9.2.2.</span> <span class="toc-text">条件检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分页检索-1"><span class="toc-number">9.2.3.</span> <span class="toc-text">分页检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#排序检索-1"><span class="toc-number">9.2.4.</span> <span class="toc-text">排序检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#统计检索-1"><span class="toc-number">9.2.5.</span> <span class="toc-text">统计检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#离线条件检索"><span class="toc-number">9.2.6.</span> <span class="toc-text">离线条件检索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多表查询"><span class="toc-number">9.3.</span> <span class="toc-text">多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多表查询基础"><span class="toc-number">9.3.1.</span> <span class="toc-text">多表查询基础:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HQL连接查询"><span class="toc-number">9.3.2.</span> <span class="toc-text">HQL连接查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate查询策略"><span class="toc-number">10.</span> <span class="toc-text">Hibernate查询策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate事务处理"><span class="toc-number">11.</span> <span class="toc-text">Hibernate事务处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事务相关的概念"><span class="toc-number">11.1.</span> <span class="toc-text">事务相关的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#丢失更新问题"><span class="toc-number">11.2.</span> <span class="toc-text">丢失更新问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定本地的Session"><span class="toc-number">11.3.</span> <span class="toc-text">绑定本地的Session</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate-二级缓存"><span class="toc-number">12.</span> <span class="toc-text">Hibernate 二级缓存</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="https://www.bcoder.top"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/zlnnjit"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=430673592"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        Use
        <a href="https://bcoder.top/" target="_blank" class="codename">周陆宁</a>
        as theme
        
          , 
          total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://bocder.top" target="_blank" rel="noopener">Copyright © 2016-2020 zlnnjit</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script>

  








  
    
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.2.0/js/valine.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var guest_info = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var notify = 'true' == true;
  var verify = 'true' == true;
  var valine = new Valine();
  valine.init({
    el: '#valine_container',
    notify: notify,
    verify: verify,
    guest_info: guest_info,
    
    appId: "M3YhrSNLSJTxyKwa8hGSGbH7-gzGzoHsz",
    appKey: "RwjMsAULtRweeA4GtaqJGPVu",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'mp',
    lang:'zh-cn',
    visitor: 'false',
    highlight:'true'
  })
  </script>



  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>



<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->

  <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>






  <script>setLoadingBarProgress(100);</script>
</body>
</html>

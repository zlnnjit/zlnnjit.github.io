<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#2020'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>微服务容器化实践（二） - zln&#39;s blog</title>
  
    <meta name="keywords" content="微服务,k8s,CI/CD">
  
  
    <meta name="description" content="Kubernetes基础Kubernetes介绍首先，Kubernetes是一个全新的基于容器技术的分布式架构领先方案。Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能，利用Kubernetes能方便地管理跨机器运行容器化的应用，其主要功能如下：

使用Docker...">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css">
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div class="cover-wrapper">
    
      <cover class='cover post half'>
        <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">bcoder.top</p>
    
    
      <p class="subtitle">不忘初心，无畏前行</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="" />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <ul class='h-list'>
        
          
            <li>
              <a class="nav home"
                href="/"
                
                
                id="home">
                <i class='fas fa-rss fa-fw'></i>&nbsp;博客
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/categories/"
                
                
                id="categories">
                <i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/tags/"
                
                
                id="tags">
                <i class='fas fa-tags fa-fw'></i>&nbsp;标签
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/archives/"
                
                
                id="archives">
                <i class='fas fa-archive fa-fw'></i>&nbsp;归档
              </a>
            </li>
          
        
      </ul>
    </div>
  </div>
</div>

      </cover>
    
    <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">

  <div class='wrapper'>
    <div class='nav-sub container--flex'>
      <a class="logo flat-box"></a>
      <ul class='switcher h-list'>
        <li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main container container--flex">
      
        
        <a class="logo flat-box" target="_self" href='/'>
          
          
          
          
            周陆宁 <b><sup style='color:#3AA757'>2020</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='h-list'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  
                    <i class='fas fa-rss fa-fw'></i>
                  
                  博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  
                    <i class='fas fa-folder-open fa-fw'></i>
                  
                  分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  
                    <i class='fas fa-tags fa-fw'></i>
                  
                  标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  
                    <i class='fas fa-archive fa-fw'></i>
                  
                  归档
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      
        <div class="m_search">
          <form name="searchform" class="form u-search-form">
            <i class="icon fas fa-search fa-fw"></i>
            <input type="text" class="input u-search-input" placeholder="搜索" />
          </form>
        </div>
      

			<ul class='switcher h-list'>
				
					<li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a></li>
			</ul>
		</div>
	</div>
</header>
<ul class="menu-phone navigation white-box">
  
  
    <li>
      <a class="flat-box" href=/
        
        
        
          id="home"
        >
        
          <i class='fas fa-rss fa-fw'></i>
        
        博客
      </a>
    </li>
  
    <li>
      <a class="flat-box" href=/categories/
        
        
        
          id="categories"
        >
        
          <i class='fas fa-folder-open fa-fw'></i>
        
        分类
      </a>
    </li>
  
    <li>
      <a class="flat-box" href=/tags/
        
        
        
          id="tags"
        >
        
          <i class='fas fa-tags fa-fw'></i>
        
        标签
      </a>
    </li>
  
    <li>
      <a class="flat-box" href=/archives/
        
        
        
          id="archives"
        >
        
          <i class='fas fa-archive fa-fw'></i>
        
        归档
      </a>
    </li>
  
    <li>
      <a class="flat-box" href=/friends/
        
        
        
          id="friends"
        >
        
          <i class='fas fa-link fa-fw'></i>
        
        友链
      </a>
    </li>
  
    <li>
      <a class="flat-box" href=/about/
        
        
        
          id="about"
        >
        
          <i class='fas fa-info-circle fa-fw'></i>
        
        关于
      </a>
    </li>
  
</ul>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/01/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89/">
        微服务容器化实践（二）
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
<div class='new-meta-item author'>
  <a href="" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>周陆宁</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/CI-CD/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>CI/CD</p>
    </a>
  </div>


          
        
          
            
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>微服务</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/k8s/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>k8s</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/CI-CD/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>CI/CD</p></a></div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2019-01-19 18:37:52</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>字数：12.5k</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>时长：54 分钟</p>
    </a>
  </div>


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h2 id="Kubernetes基础"><a href="#Kubernetes基础" class="headerlink" title="Kubernetes基础"></a>Kubernetes基础</h2><h3 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a>Kubernetes介绍</h3><p>首先，Kubernetes是一个<strong>全新的基于容器技术的分布式架构领先方案</strong>。Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能，利用Kubernetes能方便地管理跨机器运行容器化的应用，其主要功能如下：</p>
<ul>
<li>使用Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。</li>
<li>以集群的方式运行、管理跨机器的容器。</li>
<li>解决Docker跨机器容器之间的通讯问题。</li>
<li>Kubernetes的自我修复机制使得容器集群总是运行在用户期望的状态。</li>
</ul>
<a id="more"></a>

<h3 id="为什么使用Kubernetes？"><a href="#为什么使用Kubernetes？" class="headerlink" title="为什么使用Kubernetes？"></a>为什么使用Kubernetes？</h3><p>如果你曾经用过Docker容器技术部署容器，那么可以将Docker看成Kubernetes内部使用的低级别组件。Kubernetes不仅仅支持Docker，还支持Rocket，这是另一种容器技术。</p>
<ul>
<li>全面拥抱微服务架构</li>
<li>使用Kubernetes我们系统可以随时的整体迁移</li>
<li>Kubernetes系统具备了超强的横向扩容能力</li>
<li>Kubernetes提供完善的管理工具，涵盖了包括开发、部署测试、运维监控在内的各个环节。</li>
</ul>
<h3 id="Kubernetes的核心概念"><a href="#Kubernetes的核心概念" class="headerlink" title="Kubernetes的核心概念"></a>Kubernetes的核心概念</h3><p><strong>集群</strong></p>
<p>集群是一组节点，这些节点可以是物理服务器或者虚拟机，之上安装了Kubernetes平台。下图展示这样的集群。注意该图为了强调核心概念有所简化。这里可以看到一个典型的Kubernetes架构图。</p>
<p> <img src="http://img.bcoder.top/2019.01.19/1.png" alt=""></p>
<p>上图可以看到如下组件，使用特别的图标表示Service和Label：</p>
<ul>
<li>Pod</li>
<li>Container（容器）</li>
<li>Replication Controller（复制控制器）</li>
<li>Service（服务） </li>
<li>Node（节点） </li>
<li>Kubernetes Master（Kubernetes主节点）</li>
</ul>
<p><strong>Kubernetes Master</strong></p>
<p>集群拥有一个Kubernetes Master（紫色方框）。Kubernetes Master提供集群的独特视角，并且拥有一系列组件，比如Kubernetes API Server。API Server提供可以用来和集群交互的REST端点。master节点包括用来创建和复制Pod的Replication Controller。</p>
<p><strong>Pod</strong></p>
<p>Pod（上图绿色方框）安排在节点上，包含一组容器和卷。同一个Pod里的容器共享同一个网络命名空间，可以使用localhost互相通信。Pod是短暂的，不是持续性实体。你可能会有这些问题：</p>
<ul>
<li>如果Pod是短暂的，那么我怎么才能持久化容器数据使其能够跨重启而存在呢？ 是的，Kubernetes支持<a href="http://kubernetes.io/v1.1/docs/user-guide/volumes.html" target="_blank" rel="noopener">卷</a>的概念，因此可以使用持久化的卷类型。</li>
<li>是否手动创建Pod，如果想要创建同一个容器的多份拷贝，需要一个个分别创建出来么？可以手动创建单个Pod，但是也可以使用Replication Controller使用Pod模板创建出多份拷贝，下文会详细介绍。</li>
<li>如果Pod是短暂的，那么重启时IP地址可能会改变，那么怎么才能从前端容器正确可靠地指向后台容器呢？这时可以使用Service，下文会详细介绍。</li>
</ul>
<p><strong>Lable</strong></p>
<p>正如图所示，一些Pod有Label。一个Label是attach到Pod的一对键/值对，用来传递用户定义的属性。比如，你可能创建了一个”tier”和“app”标签，通过Label（<strong>tier=frontend, app=myapp</strong>）来标记前端Pod容器，使用Label（<strong>tier=backend, app=myapp</strong>）标记后台Pod。然后可以使用<a href="http://kubernetes.io/v1.1/docs/user-guide/labels.html#label-selectors" target="_blank" rel="noopener">Selectors</a>选择带有特定Label的Pod，并且将Service或者Replication Controller应用到上面。</p>
<p><strong>Replication Controller</strong></p>
<p> 是否手动创建Pod，如果想要创建同一个容器的多份拷贝，需要一个个分别创建出来么，能否将Pods划到逻辑组里？</p>
<p>Replication Controller确保任意时间都有指定数量的Pod“副本”在运行。如果为某个Pod创建了Replication Controller并且指定3个副本，它会创建3个Pod，并且持续监控它们。如果某个Pod不响应，那么Replication Controller会替换它，保持总数为3.如下面的动画所示：  </p>
<p> <img src="http://img.bcoder.top/2019.01.19/2.gif" alt=""></p>
<p>如果之前不响应的Pod恢复了，现在就有4个Pod了，那么Replication Controller会将其中一个终止保持总数为3。如果在运行中将副本总数改为5，Replication Controller会立刻启动2个新Pod，保证总数为5。还可以按照这样的方式缩小Pod，这个特性在执行滚动升级时很有用。</p>
<p>当创建Replication Controller时，需要指定两个东西：</p>
<ol>
<li><a href="http://kubernetes.io/v1.1/docs/user-guide/replication-controller.html#pod-template" target="_blank" rel="noopener">Pod模板</a>：用来创建Pod副本的模板</li>
<li><a href="http://kubernetes.io/v1.1/docs/user-guide/replication-controller.html#labels" target="_blank" rel="noopener">Label</a>：Replication Controller需要监控的Pod的标签。</li>
</ol>
<p>现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。</p>
<p><strong>Service</strong></p>
<p>如果Pods是短暂的，那么重启时IP地址可能会改变，怎么才能从前端容器正确可靠地指向后台容器呢？</p>
<p>Service是定义一系列Pod以及访问这些Pod的策略的一层抽象。Service通过Label找到Pod组。因为Service是抽象的，所以在图表里通常看不到它们的存在，这也就让这一概念更难以理解。</p>
<p>现在，假定有2个后台Pod，并且定义后台Service的名称为‘backend-service’，lable选择器为（tier=backend, app=myapp）。backend-service的Service会完成如下两件重要的事情：</p>
<ul>
<li>会为Service创建一个本地集群的DNS入口，因此前端Pod只需要DNS查找主机名为 ‘backend-service’，就能够解析出前端应用程序可用的IP地址。</li>
<li>现在前端已经得到了后台服务的IP地址，但是它应该访问2个后台Pod的哪一个呢？Service在这2个后台Pod之间提供透明的负载均衡，会将请求分发给其中的任意一个（如下面的动画所示）。通过每个Node上运行的代理（kube-proxy）完成。<a href="http://kubernetes.io/v1.1/docs/user-guide/services.html#virtual-ips-and-service-proxies" target="_blank" rel="noopener">这里</a>有更多技术细节。</li>
</ul>
<p>下述动画展示了Service的功能。注意该图作了很多简化。如果不进入网络配置，那么达到透明的负载均衡目标所涉及的底层网络和路由相对先进。</p>
<p> <img src="http://img.bcoder.top/2019.01.19/3.gif" alt=""></p>
<p>有一个特别类型的Kubernetes Service，称为’<a href="http://kubernetes.io/v1.1/docs/user-guide/services.html#type-loadbalancer" target="_blank" rel="noopener">LoadBalancer</a>‘，作为外部负载均衡器使用，在一定数量的Pod之间均衡流量。比如，对于负载均衡Web流量很有用。</p>
<p><strong>Node</strong></p>
<p>节点（上图橘色方框）是物理或者虚拟机器，作为Kubernetes worker，通常称为Minion。每个节点都运行如下Kubernetes关键组件：</p>
<ul>
<li>Kubelet：是主节点代理。</li>
<li>Kube-proxy：Service使用其将链接路由到Pod，如上文所述。</li>
<li>Docker或Rocket：Kubernetes使用的容器技术来创建容器。</li>
</ul>
<h3 id="Kubernetes的体系结构"><a href="#Kubernetes的体系结构" class="headerlink" title="Kubernetes的体系结构"></a>Kubernetes的体系结构</h3><p> <img src="http://img.bcoder.top/2019.01.19/4.png" alt=""></p>
<h2 id="Kubernetes集群搭建（环境准备）"><a href="#Kubernetes集群搭建（环境准备）" class="headerlink" title="Kubernetes集群搭建（环境准备）"></a>Kubernetes集群搭建（环境准备）</h2><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><p>这里准备了三台ubuntu虚拟机，每台4核cpu和4G内存，配置好root账户，并安装好了docker，后续的所有操作都是使用root账户。虚拟机具体信息如下表：</p>
<table>
<thead>
<tr>
<th>系统类型</th>
<th>IP地址</th>
<th>节点角色</th>
<th>CPU</th>
<th>Memory</th>
<th>Hostname</th>
</tr>
</thead>
<tbody><tr>
<td>ubuntu16.04</td>
<td>192.168.1.101</td>
<td>worker</td>
<td>1</td>
<td>2G</td>
<td>server01</td>
</tr>
<tr>
<td>ubuntu16.04</td>
<td>192.168.1.102</td>
<td>master</td>
<td>1</td>
<td>2G</td>
<td>server02</td>
</tr>
<tr>
<td>ubuntu16.04</td>
<td>192.168.1.103</td>
<td>worker</td>
<td>1</td>
<td>2G</td>
<td>server03</td>
</tr>
</tbody></table>
<p>由于笔记本资源有限，使用openstack虚拟机来进行创建三个节点，其中三台机器的浮动ip为：172.171.5.202/172.171.5.201/172.171.5.203</p>
<p> <img src="http://img.bcoder.top/2019.01.19/5.png" alt=""></p>
<h3 id="安装docker（所有节点）"><a href="#安装docker（所有节点）" class="headerlink" title="安装docker（所有节点）"></a>安装docker（所有节点）</h3><p>一般情况使用下面的方法安装即可</p>
<h4 id="1-卸载旧版本-如果有的话"><a href="#1-卸载旧版本-如果有的话" class="headerlink" title="1 卸载旧版本(如果有的话)"></a>1 卸载旧版本(如果有的话)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure>

<h4 id="2-更新apt-get源"><a href="#2-更新apt-get源" class="headerlink" title="2 更新apt-get源"></a>2 更新apt-get源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add-apt-repository  "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</span><br><span class="line"></span><br><span class="line">apt-get update #如果失败执行2.3步之后再来执行</span><br></pre></td></tr></table></figure>

<h4 id="3-安装apt的https支持包并添加gpg秘钥"><a href="#3-安装apt的https支持包并添加gpg秘钥" class="headerlink" title="3 安装apt的https支持包并添加gpg秘钥"></a>3 安装apt的https支持包并添加gpg秘钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -</span><br></pre></td></tr></table></figure>

<h4 id="4-安装docker-ce"><a href="#4-安装docker-ce" class="headerlink" title="4 安装docker-ce"></a>4 安装docker-ce</h4><ul>
<li>安装最新的稳定版</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y docker-ce</span><br></pre></td></tr></table></figure>

<ul>
<li>安装指定版本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取版本列表</span></span><br><span class="line">apt-cache madison docker-ce</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">指定版本安装(比如版本是17.09.1~ce-0~ubuntu)</span></span><br><span class="line">apt-get install -y docker-ce=17.09.1~ce-0~ubuntu</span><br></pre></td></tr></table></figure>

<ul>
<li>接受所有ip的数据包转发</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /lib/systemd/system/docker.service</span><br><span class="line">   </span><br><span class="line"><span class="meta">#</span><span class="bash">找到ExecStart=xxx，在这行上面加入一行，内容如下：(k8s的网络需要)</span></span><br><span class="line">ExecStartPost=/sbin/iptables -I FORWARD -s 0.0.0.0/0 -j ACCEPT</span><br></pre></td></tr></table></figure>

<ul>
<li>启动服务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure>

<h3 id="系统设置（所有节点）"><a href="#系统设置（所有节点）" class="headerlink" title="系统设置（所有节点）"></a>系统设置（所有节点）</h3><h4 id="1-关闭、禁用防火墙-让所有机器之间都可以通过任意端口建立连接"><a href="#1-关闭、禁用防火墙-让所有机器之间都可以通过任意端口建立连接" class="headerlink" title="1 关闭、禁用防火墙(让所有机器之间都可以通过任意端口建立连接)"></a>1 关闭、禁用防火墙(让所有机器之间都可以通过任意端口建立连接)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ufw <span class="built_in">disable</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ufw status</span></span><br></pre></td></tr></table></figure>

<h4 id="2-设置系统参数-允许路由转发，不对bridge的数据进行处理"><a href="#2-设置系统参数-允许路由转发，不对bridge的数据进行处理" class="headerlink" title="2 设置系统参数 - 允许路由转发，不对bridge的数据进行处理"></a>2 设置系统参数 - 允许路由转发，不对bridge的数据进行处理</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">写入配置文件</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">生效配置文件</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure>

<h4 id="3-配置host文件"><a href="#3-配置host文件" class="headerlink" title="3 配置host文件"></a>3 配置host文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#配置host，使每个Node都可以通过名字解析到ip地址</span><br><span class="line">vi &#x2F;etc&#x2F;hosts</span><br><span class="line">#加入如下片段(ip地址和servername替换成自己的)</span><br><span class="line">192.168.1.101 server01</span><br><span class="line">192.168.1.102 server02</span><br><span class="line">192.168.1.103 server03</span><br></pre></td></tr></table></figure>

<h3 id="准备二进制文件（所有节点）"><a href="#准备二进制文件（所有节点）" class="headerlink" title="准备二进制文件（所有节点）"></a>准备二进制文件（所有节点）</h3><p>kubernetes的安装有几种方式，不管是kube-admin还是社区贡献的部署方案都离不开这几种方式：</p>
<ul>
<li><strong>使用现成的二进制文件</strong></li>
</ul>
<blockquote>
<p>直接从官方或其他第三方下载，就是kubernetes各个组件的可执行文件。拿来就可以直接运行了。不管是centos，ubuntu还是其他的linux发行版本，只要gcc编译环境没有太大的区别就可以直接运行的。使用较新的系统一般不会有什么跨平台的问题。</p>
</blockquote>
<ul>
<li><strong>使用源码编译安装</strong></li>
</ul>
<blockquote>
<p>编译结果也是各个组件的二进制文件，所以如果能直接下载到需要的二进制文件基本没有什么编译的必要性了。</p>
</blockquote>
<ul>
<li><strong>使用镜像的方式运行</strong></li>
</ul>
<blockquote>
<p>同样一个功能使用二进制文件提供的服务，也可以选择使用镜像的方式。就像nginx，像mysql，我们可以使用安装版，搞一个可执行文件运行起来，也可以使用它们的镜像运行起来，提供同样的服务。kubernetes也是一样的道理，二进制文件提供的服务镜像也一样可以提供。</p>
</blockquote>
<p>从上面的三种方式中其实使用镜像是比较优雅的方案，容器的好处自然不用多说。但从初学者的角度来说容器的方案会显得有些复杂，不那么纯粹，会有很多容器的配置文件以及关于类似二进制文件提供的服务如何在容器中提供的问题，容易跑偏。 所以我们这里使用二进制的方式来部署。二进制文件已经这里备好，大家可以打包下载，把下载好的文件放到每个节点上，放在哪个目录随你喜欢，<strong>放好后最好设置一下环境变量$PATH</strong>，方便后面可以直接使用命令。(科学上网的同学也可以自己去官网找找)</p>
<p><a href="https://pan.baidu.com/s/1bMnqWY" target="_blank" rel="noopener">下载地址（kubernetes 1.9.0版本）</a> </p>
<h3 id="准备配置文件（所有节点）"><a href="#准备配置文件（所有节点）" class="headerlink" title="准备配置文件（所有节点）"></a>准备配置文件（所有节点）</h3><p>上一步我们下载了kubernetes各个组件的二进制文件，这些可执行文件的运行也是需要添加很多参数的，包括有的还会依赖一些配置文件。现在我们就把运行它们需要的参数和配置文件都准备好。</p>
<h4 id="1-下载配置文件"><a href="#1-下载配置文件" class="headerlink" title="1 下载配置文件"></a>1 下载配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">到home目录下载项目</span></span><br><span class="line">cd /home/openlab</span><br><span class="line">git clone https://github.com/liuyi01/kubernetes-starter.git</span><br><span class="line"><span class="meta">#</span><span class="bash">看看git内容</span></span><br><span class="line">cd /home/openlab/kubernetes-starter &amp;&amp; ls</span><br></pre></td></tr></table></figure>

<h4 id="2-文件说明"><a href="#2-文件说明" class="headerlink" title="2 文件说明"></a>2 文件说明</h4><ul>
<li><strong>gen-config.sh</strong></li>
</ul>
<blockquote>
<p>shell脚本，用来根据每个同学自己的集群环境(ip，hostname等)，根据下面的模板，生成适合大家各自环境的配置文件。生成的文件会放到target文件夹下。</p>
</blockquote>
<ul>
<li><strong>kubernetes-simple</strong></li>
</ul>
<blockquote>
<p>简易版kubernetes配置模板（剥离了认证授权）。 适合刚接触kubernetes的同学，首先会让大家在和kubernetes初次见面不会印象太差（太复杂啦~~），再有就是让大家更容易抓住kubernetes的核心部分，把注意力集中到核心组件及组件的联系，从整体上把握kubernetes的运行机制。</p>
</blockquote>
<ul>
<li><strong>kubernetes-with-ca</strong></li>
</ul>
<blockquote>
<p>在simple基础上增加认证授权部分。大家可以自行对比生成的配置文件，看看跟simple版的差异，更容易理解认证授权的（认证授权也是kubernetes学习曲线较高的重要原因）</p>
</blockquote>
<ul>
<li><strong>service-config</strong></li>
</ul>
<blockquote>
<p>这个先不用关注，它是我们曾经开发的那些微服务配置。 等我们熟悉了kubernetes后，实践用的，通过这些配置，把我们的微服务都运行到kubernetes集群中。</p>
</blockquote>
<h4 id="3-生成配置"><a href="#3-生成配置" class="headerlink" title="3 生成配置"></a>3 生成配置</h4><p>这里会根据大家各自的环境生成kubernetes部署过程需要的配置文件。 在每个节点上都生成一遍，把所有配置都生成好，后面会根据节点类型去使用相关的配置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">cd</span>到之前下载的git代码目录</span></span><br><span class="line">cd /home/openlab/kubernetes-starter</span><br><span class="line"><span class="meta">#</span><span class="bash">编辑属性配置（根据文件注释中的说明填写好每个key-value）</span></span><br><span class="line">vi config.properties</span><br><span class="line"><span class="meta">#</span><span class="bash">生成配置文件，确保执行过程没有异常信息</span></span><br><span class="line">./gen-config.sh simple</span><br><span class="line"><span class="meta">#</span><span class="bash">查看生成的配置文件，确保脚本执行成功</span></span><br><span class="line">find target/ -type f</span><br><span class="line">target/all-node/kube-calico.service</span><br><span class="line">target/master-node/kube-controller-manager.service</span><br><span class="line">target/master-node/kube-apiserver.service</span><br><span class="line">target/master-node/etcd.service</span><br><span class="line">target/master-node/kube-scheduler.service</span><br><span class="line">target/worker-node/kube-proxy.kubeconfig</span><br><span class="line">target/worker-node/kubelet.service</span><br><span class="line">target/worker-node/10-calico.conf</span><br><span class="line">target/worker-node/kubelet.kubeconfig</span><br><span class="line">target/worker-node/kube-proxy.service</span><br><span class="line">target/services/kube-dns.yaml</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>执行gen-config.sh常见问题：</strong></p>
<ol>
<li>gen-config.sh: 3: gen-config.sh: Syntax error: “(“ unexpected</li>
</ol>
<ul>
<li>bash版本过低，运行：bash -version查看版本，如果小于4需要升级</li>
<li>不要使用 sh gen-config.sh的方式运行（sh和bash可能不一样哦）</li>
</ul>
<ol>
<li>config.properties文件填写错误，需要重新生成 再执行一次./gen-config.sh simple即可，不需要手动删除target</li>
</ol>
</blockquote>
<h2 id="Kubernetes集群搭建（基础功能安装）"><a href="#Kubernetes集群搭建（基础功能安装）" class="headerlink" title="Kubernetes集群搭建（基础功能安装）"></a>Kubernetes集群搭建（基础功能安装）</h2><h3 id="部署ETCD（主节点）"><a href="#部署ETCD（主节点）" class="headerlink" title="部署ETCD（主节点）"></a>部署ETCD（主节点）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>kubernetes需要存储很多东西，像它本身的节点信息，组件信息，还有通过kubernetes运行的pod，deployment，service等等。都需要持久化。etcd就是它的数据中心。生产环境中为了保证数据中心的高可用和数据的一致性，一般会部署最少三个节点。我们这里以学习为主就只在主节点部署一个实例。</p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p><strong>etcd的二进制文件和服务的配置我们都已经准备好，现在的目的就是把它做成系统服务并启动。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">把服务配置文件copy到系统服务目录</span></span><br><span class="line">cp /home/openlab/kubernetes-starter/target/master-node/etcd.service /lib/systemd/system/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">enable</span>服务</span></span><br><span class="line">systemctl enable etcd.service</span><br><span class="line"><span class="meta">#</span><span class="bash">创建工作目录(保存数据的地方)</span></span><br><span class="line">mkdir -p /var/lib/etcd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">service etcd start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务日志，看是否有错误信息，确保服务正常</span></span><br><span class="line">journalctl -f -u etcd.service</span><br></pre></td></tr></table></figure>



<p>etcd.service内容为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Documentation=https://github.com/coreos</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">WorkingDirectory=/var/lib/etcd/</span><br><span class="line">ExecStart=/home/openlab/bin/etcd \</span><br><span class="line">  --name=192.168.1.102 \</span><br><span class="line">  --listen-client-urls=http://192.168.1.102:2379,http://127.0.0.1:2379 \</span><br><span class="line">  --advertise-client-urls=http://192.168.1.102:2379 \</span><br><span class="line">  --data-dir=/var/lib/etcd</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h3 id="部署APIServer（主节点）"><a href="#部署APIServer（主节点）" class="headerlink" title="部署APIServer（主节点）"></a>部署APIServer（主节点）</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>kube-apiserver是Kubernetes最重要的核心组件之一，主要提供以下的功能</p>
<ul>
<li>提供集群管理的REST API接口，包括认证授权（我们现在没有用到）数据校验以及集群状态变更等</li>
<li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）</li>
</ul>
<blockquote>
<p>生产环境为了保证apiserver的高可用一般会部署2+个节点，在上层做一个lb做负载均衡，比如haproxy。由于单节点和多节点在apiserver这一层说来没什么区别，所以我们学习部署一个节点就足够啦</p>
</blockquote>
<h4 id="2-部署"><a href="#2-部署" class="headerlink" title="2.部署"></a>2.部署</h4><p>APIServer的部署方式也是通过系统服务。部署流程跟etcd完全一样，不再注释</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp target/master-node/kube-apiserver.service /lib/systemd/system/</span><br><span class="line">systemctl enable kube-apiserver.service</span><br><span class="line">service kube-apiserver start</span><br><span class="line">journalctl -f -u kube-apiserver</span><br></pre></td></tr></table></figure>



<p>target/master-node/kube-apiserver.service</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes API Server</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line"><span class="meta">#</span><span class="bash">可执行文件的位置</span></span><br><span class="line">ExecStart=/home/openlab/bin/kube-apiserver \</span><br><span class="line">  --admission-control=NamespaceLifecycle,LimitRanger,DefaultStorageClass,ResourceQuota,NodeRestriction \</span><br><span class="line"><span class="meta">  #</span><span class="bash">非安全端口(8080)绑定的监听地址 这里表示监听所有地址</span></span><br><span class="line">  --insecure-bind-address=0.0.0.0 \</span><br><span class="line"><span class="meta">  #</span><span class="bash">不使用https</span></span><br><span class="line">  --kubelet-https=false \</span><br><span class="line"><span class="meta">  #</span><span class="bash">kubernetes集群的虚拟ip的地址范围</span></span><br><span class="line">  --service-cluster-ip-range=10.68.0.0/16 \</span><br><span class="line"><span class="meta">  #</span><span class="bash">service的nodeport的端口范围限制</span></span><br><span class="line">  --service-node-port-range=20000-40000 \</span><br><span class="line"><span class="meta">  #</span><span class="bash">很多地方都需要和etcd打交道，也是唯一可以直接操作etcd的模块</span></span><br><span class="line">  --etcd-servers=http://192.168.1.102:2379 \</span><br><span class="line">  --enable-swagger-ui=true \</span><br><span class="line">  --allow-privileged=true \</span><br><span class="line">  --audit-log-maxage=30 \</span><br><span class="line">  --audit-log-maxbackup=3 \</span><br><span class="line">  --audit-log-maxsize=100 \</span><br><span class="line">  --audit-log-path=/var/lib/audit.log \</span><br><span class="line">  --event-ttl=1h \</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">Type=notify</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h3 id="部署ControllerManager（主节点）"><a href="#部署ControllerManager（主节点）" class="headerlink" title="部署ControllerManager（主节点）"></a>部署ControllerManager（主节点）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Controller Manager由kube-controller-manager和cloud-controller-manager组成，是Kubernetes的大脑，它通过apiserver监控整个集群的状态，并确保集群处于预期的工作状态。 kube-controller-manager由一系列的控制器组成，像Replication Controller控制副本，Node Controller节点控制，Deployment Controller管理deployment等等 cloud-controller-manager在Kubernetes启用Cloud Provider的时候才需要，用来配合云服务提供商的控制</p>
<blockquote>
<p>controller-manager、scheduler和apiserver 三者的功能紧密相关，一般运行在同一个机器上，我们可以把它们当做一个整体来看，所以保证了apiserver的高可用即是保证了三个模块的高可用。也可以同时启动多个controller-manager进程，但只有一个会被选举为leader提供服务。</p>
</blockquote>
<h4 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp target/master-node/kube-controller-manager.service /lib/systemd/system/</span><br><span class="line">systemctl enable kube-controller-manager.service</span><br><span class="line">service kube-controller-manager start</span><br><span class="line">journalctl -f -u kube-controller-manager</span><br></pre></td></tr></table></figure>



<p>kube-controller-manager.service</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Controller Manager</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/openlab/bin/kube-controller-manager \</span><br><span class="line"><span class="meta">#</span><span class="bash">对外服务的监听地址，这里表示只有本机的程序可以访问它</span></span><br><span class="line">  --address=127.0.0.1 \</span><br><span class="line"><span class="meta">  #</span><span class="bash">apiserver的url</span></span><br><span class="line">  --master=http://127.0.0.1:8080 \</span><br><span class="line">  --allocate-node-cidrs=true \</span><br><span class="line"><span class="meta">  #</span><span class="bash">服务虚拟ip范围，同apiserver的配置</span></span><br><span class="line">  --service-cluster-ip-range=10.68.0.0/16 \</span><br><span class="line"><span class="meta">  #</span><span class="bash">pod的ip地址范围</span></span><br><span class="line">  --cluster-cidr=172.20.0.0/16 \</span><br><span class="line">  --cluster-name=kubernetes \</span><br><span class="line">  --leader-elect=true \</span><br><span class="line"><span class="meta">  #</span><span class="bash">下面两个表示不使用证书，用空值覆盖默认值</span></span><br><span class="line">  --cluster-signing-cert-file= \</span><br><span class="line">  --cluster-signing-key-file= \</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<h3 id="部署Scheduler（主节点）"><a href="#部署Scheduler（主节点）" class="headerlink" title="部署Scheduler（主节点）"></a>部署Scheduler（主节点）</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>kube-scheduler负责分配调度Pod到集群内的节点上，它监听kube-apiserver，查询还未分配Node的Pod，然后根据调度策略为这些Pod分配节点。我们前面讲到的kubernetes的各种调度策略就是它实现的。</p>
<h4 id="部署-2"><a href="#部署-2" class="headerlink" title="部署"></a>部署</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp target/master-node/kube-scheduler.service /lib/systemd/system/</span><br><span class="line">systemctl enable kube-scheduler.service</span><br><span class="line">service kube-scheduler start</span><br><span class="line">journalctl -f -u kube-scheduler</span><br></pre></td></tr></table></figure>



<p>kube-scheduler.service</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Scheduler</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/openlab/bin/kube-scheduler \</span><br><span class="line"><span class="meta">#</span><span class="bash">对外服务的监听地址，这里表示只有本机的程序可以访问它</span></span><br><span class="line">  --address=127.0.0.1 \</span><br><span class="line">  --master=http://127.0.0.1:8080 \</span><br><span class="line">  --leader-elect=true \</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<h3 id="部署CalicoNode（所有节点）"><a href="#部署CalicoNode（所有节点）" class="headerlink" title="部署CalicoNode（所有节点）"></a>部署CalicoNode（所有节点）</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>Calico实现了CNI接口，是kubernetes网络方案的一种选择，它一个纯三层的数据中心网络方案（不需要Overlay），并且与OpenStack、Kubernetes、AWS、GCE等IaaS和容器平台都有良好的集成。 Calico在每一个计算节点利用Linux Kernel实现了一个高效的vRouter来负责数据转发，而每个vRouter通过BGP协议负责把自己上运行的workload的路由信息像整个Calico网络内传播——小规模部署可以直接互联，大规模下可通过指定的BGP route reflector来完成。 这样保证最终所有的workload之间的数据流量都是通过IP路由的方式完成互联的。</p>
<h4 id="部署-3"><a href="#部署-3" class="headerlink" title="部署"></a>部署</h4><p><strong>calico是通过系统服务+docker方式完成的</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp target/all-node/kube-calico.service /lib/systemd/system/</span><br><span class="line">systemctl enable kube-calico.service</span><br><span class="line">service kube-calico start</span><br><span class="line">journalctl -f -u kube-calico</span><br></pre></td></tr></table></figure>



<p>kube-calico.service</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=calico node</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">PermissionsStartOnly=true</span><br><span class="line"><span class="meta">#</span><span class="bash">以docker方式运行</span></span><br><span class="line">ExecStart=/usr/bin/docker run --net=host --privileged --name=calico-node \</span><br><span class="line"><span class="meta">#</span><span class="bash">指定etcd endpoints（这里主要负责网络元数据一致性，确保Calico网络状态的准确性）</span></span><br><span class="line">  -e ETCD_ENDPOINTS=http://192.168.1.102:2379 \</span><br><span class="line">  -e CALICO_LIBNETWORK_ENABLED=true \</span><br><span class="line">  -e CALICO_NETWORKING_BACKEND=bird \</span><br><span class="line">  -e CALICO_DISABLE_FILE_LOGGING=true \</span><br><span class="line"><span class="meta">  #</span><span class="bash">网络地址范围（同上面ControllerManager）</span></span><br><span class="line">  -e CALICO_IPV4POOL_CIDR=192.1.0.0/16 \</span><br><span class="line">  -e CALICO_IPV4POOL_IPIP=off \</span><br><span class="line">  -e FELIX_DEFAULTENDPOINTTOHOSTACTION=ACCEPT \</span><br><span class="line">  -e FELIX_IPV6SUPPORT=false \</span><br><span class="line">  -e FELIX_LOGSEVERITYSCREEN=info \</span><br><span class="line">  -e FELIX_IPINIPMTU=1440 \</span><br><span class="line">  -e FELIX_HEALTHENABLED=true \</span><br><span class="line"><span class="meta">  #</span><span class="bash">镜像名，为了加快大家的下载速度，镜像都放到了阿里云上</span></span><br><span class="line">  -e IP=192.168.1.102 \</span><br><span class="line">  -v /var/run/calico:/var/run/calico \</span><br><span class="line">  -v /lib/modules:/lib/modules \</span><br><span class="line">  -v /run/docker/plugins:/run/docker/plugins \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  -v /var/log/calico:/var/log/calico \</span><br><span class="line">  registry.cn-hangzhou.aliyuncs.com/imooc/calico-node:v2.6.2</span><br><span class="line">ExecStop=/usr/bin/docker rm -f calico-node</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><strong>查看容器运行情况</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                                        COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">72f8c6b16ec6        registry.cn-hangzhou.aliyuncs.com/imooc/calico-node:v2.6.2   "start_runit"       43 minutes ago      Up 43 minutes                           calico-node</span><br></pre></td></tr></table></figure>

<p><strong>查看节点运行情况</strong>(主节点)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# calicoctl node status</span><br><span class="line">Calico process is running.</span><br><span class="line"></span><br><span class="line">IPv4 BGP status</span><br><span class="line">+---------------+-------------------+-------+----------+-------------+</span><br><span class="line">| PEER ADDRESS  |     PEER TYPE     | STATE |  SINCE   |    INFO     |</span><br><span class="line">+---------------+-------------------+-------+----------+-------------+</span><br><span class="line">| 192.168.1.103 | node-to-node mesh | up    | 13:24:30 | Established |</span><br><span class="line">| 192.168.1.101 | node-to-node mesh | up    | 13:24:59 | Established |</span><br><span class="line">+---------------+-------------------+-------+----------+-------------+</span><br><span class="line"></span><br><span class="line">IPv6 BGP status</span><br><span class="line">No IPv6 peers found.</span><br></pre></td></tr></table></figure>



<p><strong>还可以查看docker日志</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f 72f8c6b16ec6</span><br></pre></td></tr></table></figure>



<p><strong>查看端口BGP 协议是通过TCP 连接来建立邻居的，因此可以用netstat 命令验证 BGP Peer</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# netstat -natp|grep ESTABLISHED|grep 179</span><br><span class="line">tcp        0      0 192.168.1.102:33841     192.168.1.103:179       ESTABLISHED 9376/bird       </span><br><span class="line">tcp        0      0 192.168.1.102:59895     192.168.1.101:179       ESTABLISHED 9376/bird</span><br></pre></td></tr></table></figure>



<p><strong>查看集群ippool情况(主节点)</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# calicoctl get ipPool -o yaml</span><br><span class="line">- apiVersion: v1</span><br><span class="line">  kind: ipPool</span><br><span class="line">  metadata:</span><br><span class="line">    cidr: 172.20.0.0/16</span><br><span class="line">  spec:</span><br><span class="line">    nat-outgoing: true</span><br></pre></td></tr></table></figure>

<h3 id="配置kubectl命令（任意节点）"><a href="#配置kubectl命令（任意节点）" class="headerlink" title="配置kubectl命令（任意节点）"></a>配置kubectl命令（任意节点）</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>kubectl是Kubernetes的命令行工具，是Kubernetes用户和管理员必备的管理工具。 kubectl提供了大量的子命令，方便管理Kubernetes集群中的各种功能。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>使用kubectl的第一步是配置Kubernetes集群以及认证方式，包括：</p>
<ul>
<li>cluster信息：api-server地址</li>
<li>用户信息：用户名、密码或密钥</li>
<li>Context：cluster、用户信息以及Namespace的组合</li>
</ul>
<p>我们这没有安全相关的东西，只需要设置好api-server和上下文就好啦：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">指定apiserver地址（ip替换为你自己的api-server地址）</span></span><br><span class="line">kubectl config set-cluster kubernetes  --server=http://192.168.1.102:8080</span><br><span class="line"><span class="meta">#</span><span class="bash">指定设置上下文，指定cluster</span></span><br><span class="line">kubectl config set-context kubernetes --cluster=kubernetes</span><br><span class="line"><span class="meta">#</span><span class="bash">选择默认的上下文</span></span><br><span class="line">kubectl config use-context kubernetes</span><br></pre></td></tr></table></figure>

<p>通过上面的设置最终目的是生成了一个配置文件：~/.kube/config，当然你也可以手写或复制一个文件放在那，就不需要上面的命令了。</p>
<p><strong>测试是否成功(获取pod)：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# kubectl get pods</span><br><span class="line">No resources found</span><br></pre></td></tr></table></figure>



<h3 id="配置kubelet（工作节点）"><a href="#配置kubelet（工作节点）" class="headerlink" title="配置kubelet（工作节点）"></a>配置kubelet（工作节点）</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>每个工作节点上都运行一个kubelet服务进程，默认监听10250端口，接收并执行master发来的指令，管理Pod及Pod中的容器。每个kubelet进程会在API Server上注册节点自身信息，定期向master节点汇报节点的资源使用情况，并通过cAdvisor监控节点和容器的资源。</p>
<h4 id="部署-4"><a href="#部署-4" class="headerlink" title="部署"></a>部署</h4><p><strong>通过系统服务方式部署，但步骤会多一些，具体如下：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">确保相关目录存在</span></span><br><span class="line">mkdir -p /var/lib/kubelet</span><br><span class="line">mkdir -p /etc/kubernetes</span><br><span class="line">mkdir -p /etc/cni/net.d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">复制kubelet服务配置文件</span></span><br><span class="line">cp target/worker-node/kubelet.service /lib/systemd/system/</span><br><span class="line"><span class="meta">#</span><span class="bash">复制kubelet依赖的配置文件</span></span><br><span class="line">cp target/worker-node/kubelet.kubeconfig /etc/kubernetes/</span><br><span class="line"><span class="meta">#</span><span class="bash">复制kubelet用到的cni插件配置文件</span></span><br><span class="line">cp target/worker-node/10-calico.conf /etc/cni/net.d/</span><br><span class="line"></span><br><span class="line">systemctl enable kubelet.service</span><br><span class="line">service kubelet start</span><br><span class="line">journalctl -f -u kubelet</span><br></pre></td></tr></table></figure>



<p>10-calico.conf</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"calico-k8s-network"</span>,</span><br><span class="line">    <span class="attr">"cniVersion"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"calico"</span>,</span><br><span class="line">    &lt;!--etcd的url--&gt;</span><br><span class="line">    "etcd_endpoints": "http://192.168.1.102:2379",</span><br><span class="line">    "log_level": "info",</span><br><span class="line">    "ipam": &#123;</span><br><span class="line">        "type": "calico-ipam"</span><br><span class="line">    &#125;,</span><br><span class="line">    "kubernetes": &#123;</span><br><span class="line">        &lt;!--api-server的url--&gt;        </span><br><span class="line">        "k8s_api_root": "http://192.168.1.101:8080"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kubelet.kubeconfig</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">	<span class="comment">#跳过tls，即是kubernetes的认证</span></span><br><span class="line">    <span class="attr">insecure-skip-tls-verify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#api-server地址</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">http://192.168.1.102:8080</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">kubernetes</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:node:kube-master</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">system:node:kube-master</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">preferences:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">users:</span> <span class="string">[]</span></span><br></pre></td></tr></table></figure>

<p>kubelet.service</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kubelet</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="meta">#</span><span class="bash">kubelet工作目录，存储当前节点容器，pod等信息</span></span><br><span class="line">WorkingDirectory=/var/lib/kubelet</span><br><span class="line">ExecStart= /home/openlab/bin/kubelet \</span><br><span class="line"><span class="meta">#</span><span class="bash">对外服务的监听地址</span></span><br><span class="line">  --address=192.168.1.101 \</span><br><span class="line">  --hostname-override=192.168.1.101 \</span><br><span class="line"><span class="meta">  #</span><span class="bash">指定基础容器的镜像，负责创建Pod 内部共享的网络、文件系统等，这个基础容器非常重要：K8S每一个运行的 POD里面必然包含这个基础容器，如果它没有运行起来那么你的POD 肯定创建不了</span></span><br><span class="line">  --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/imooc/pause-amd64:3.0 \</span><br><span class="line"><span class="meta">  #</span><span class="bash">访问集群方式的配置，如api-server地址等</span></span><br><span class="line">  --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \</span><br><span class="line"><span class="meta">  #</span><span class="bash">声明cni网络插件</span></span><br><span class="line">  --network-plugin=cni \</span><br><span class="line"><span class="meta">  #</span><span class="bash">cni网络配置目录，kubelet会读取该目录下得网络配置</span></span><br><span class="line">  --cni-conf-dir=/etc/cni/net.d \</span><br><span class="line">  --cni-bin-dir= /root/bin \</span><br><span class="line"><span class="meta">  #</span><span class="bash">指定 kubedns 的 Service IP(可以先分配，后续创建 kubedns 服务时指定该 IP)，--cluster-domain 指定域名后缀，这两个参数同时指定后才会生效</span></span><br><span class="line">  --cluster-dns=10.68.0.2 \</span><br><span class="line">  --cluster-domain=cluster.local. \</span><br><span class="line">  --allow-privileged=true \</span><br><span class="line">  --fail-swap-on=false \</span><br><span class="line">  --logtostderr=true \</span><br><span class="line">  --v=2</span><br><span class="line"><span class="meta">#</span><span class="bash">kubelet cAdvisor 默认在所有接口监听 4194 端口的请求, 以下iptables限制内网访问</span></span><br><span class="line">ExecStartPost=/sbin/iptables -A INPUT -s 10.0.0.0/8 -p tcp --dport 4194 -j ACCEPT</span><br><span class="line">ExecStartPost=/sbin/iptables -A INPUT -s 172.16.0.0/12 -p tcp --dport 4194 -j ACCEPT</span><br><span class="line">ExecStartPost=/sbin/iptables -A INPUT -s 192.168.0.0/16 -p tcp --dport 4194 -j ACCEPT</span><br><span class="line">ExecStartPost=/sbin/iptables -A INPUT -p tcp --dport 4194 -j DROP</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<p><strong>验证</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# kubectl get nodes</span><br><span class="line">NAME            STATUS    ROLES     AGE       VERSION</span><br><span class="line">192.168.1.101   Ready     &lt;none&gt;    9m        v1.9.0</span><br><span class="line">192.168.1.103   Ready     &lt;none&gt;    16m       v1.9.0</span><br></pre></td></tr></table></figure>



<h2 id="基础集群测试"><a href="#基础集群测试" class="headerlink" title="基础集群测试"></a>基础集群测试</h2><p>查看kubectl客户端和服务端版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# kubectl version</span><br><span class="line">Client Version: version.Info&#123;Major:"1", Minor:"9", GitVersion:"v1.9.0", GitCommit:"925c127ec6b946659ad0fd596fa959be43f0cc05", GitTreeState:"clean", BuildDate:"2017-12-15T21:07:38Z", GoVersion:"go1.9.2", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:"1", Minor:"9", GitVersion:"v1.9.0", GitCommit:"925c127ec6b946659ad0fd596fa959be43f0cc05", GitTreeState:"clean", BuildDate:"2017-12-15T20:55:30Z", GoVersion:"go1.9.2", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br></pre></td></tr></table></figure>



<p>获取节点信息和pods：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# kubectl get nodes</span><br><span class="line">NAME            STATUS    ROLES     AGE       VERSION</span><br><span class="line">192.168.1.101   Ready     &lt;none&gt;    14m       v1.9.0</span><br><span class="line">192.168.1.103   Ready     &lt;none&gt;    21m       v1.9.0</span><br><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# kubectl get pods</span><br><span class="line">No resources found.</span><br><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# kubectl get --help</span><br></pre></td></tr></table></figure>



<p>创建一个deployment</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建deployment</span></span><br><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# kubectl run kubernetes-bootcamp --image=jocatalin/kubernetes-bootcamp:v1 --port=8080</span><br><span class="line">deployment "kubernetes-bootcamp" created</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看deployment</span></span><br><span class="line">root@k8s-master:/home/openlab/kubernetes-starter#  kubectl get deployments</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   1         1         1            0           57s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看pods</span></span><br><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS              RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mvmbm   0/1       ContainerCreating   0          2m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看pods详细信息</span></span><br><span class="line">root@k8s-master:/home/openlab/kubernetes-starter# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS              RESTARTS   AGE       IP        NODE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mvmbm   0/1       ContainerCreating   0          2m        &lt;none&gt;    192.168.1.103</span><br></pre></td></tr></table></figure>



<h2 id="Kubernetes集群搭建（完整）"><a href="#Kubernetes集群搭建（完整）" class="headerlink" title="Kubernetes集群搭建（完整）"></a>Kubernetes集群搭建（完整）</h2><h3 id="理解认证授权"><a href="#理解认证授权" class="headerlink" title="理解认证授权"></a>理解认证授权</h3><h4 id="1-为什么要认证"><a href="#1-为什么要认证" class="headerlink" title="1.为什么要认证"></a>1.为什么要认证</h4><p>想理解认证，我们得从认证解决什么问题、防止什么问题的发生入手。<br>防止什么问题呢？是防止有人入侵你的集群，root你的机器后让我们集群依然安全吗？不是吧，root都到手了，那就为所欲为，防不胜防了。<br>其实网络安全本身就是为了解决在某些假设成立的条件下如何防范的问题。比如一个非常重要的假设就是两个节点或者ip之间的通讯网络是不可信任的，可能会被第三方窃取，也可能会被第三方篡改。就像我们上学时候给心仪的女孩传纸条，传送的过程可能会被别的同学偷看，甚至内容可能会从我喜欢你修改成我不喜欢你了。当然这种假设不是随便想出来的，而是从网络技术现状和实际发生的问题中发现、总结出来的。kubernetes的认证也是从这个问题出发来实现的。</p>
<h4 id="2-概念梳理"><a href="#2-概念梳理" class="headerlink" title="2.概念梳理"></a>2.概念梳理</h4><p>为了解决上面说的问题，kubernetes并不需要自己想办法，毕竟是网络安全层面的问题，是每个服务都会遇到的问题，业内也有成熟的方案来解决。这里我们一起了解一下业内方案和相关的概念。</p>
<ul>
<li><strong>对称加密/非对称加密</strong> 这两个概念属于密码学的东西，对于没接触过的同学不太容易理解。可以参考知乎大神的生动讲解：<a href="https://www.zhihu.com/question/33645891/answer/57721969" target="_blank" rel="noopener">《如何用通俗易懂的话来解释非对称加密》</a></li>
<li><strong>SSL/TLS</strong> 了解了对称加密和非对称加密后，我们就可以了解一下SSL/TLS了。同样，已经有大神总结了非常好的入门文章：<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">《SSL/TLS协议运行机制的概述》</a></li>
</ul>
<h4 id="3-什么是授权"><a href="#3-什么是授权" class="headerlink" title="3.什么是授权"></a>3.什么是授权</h4><p>授权的概念就简单多了，就是什么人具有什么样的权限，一般通过角色作为纽带把他们组合在一起。也就是一个角色一边拥有多种权限，一边拥有多个人。这样就把人和权限建立了一个关系。</p>
<h3 id="kubernetes的认证授权"><a href="#kubernetes的认证授权" class="headerlink" title="kubernetes的认证授权"></a>kubernetes的认证授权</h3><p>Kubernetes集群的所有操作基本上都是通过kube-apiserver这个组件进行的，它提供HTTP RESTful形式的API供集群内外客户端调用。需要注意的是：认证授权过程只存在HTTPS形式的API中。也就是说，如果客户端使用HTTP连接到kube-apiserver，那么是不会进行认证授权的。所以说，可以这么设置，在集群内部组件间通信使用HTTP，集群外部就使用HTTPS，这样既增加了安全性，也不至于太复杂。<br>对APIServer的访问要经过的三个步骤，前面两个是认证和授权，第三个是 Admission Control，它也能在一定程度上提高安全性，不过更多是资源管理方面的作用。</p>
<h4 id="1-kubernetes的认证"><a href="#1-kubernetes的认证" class="headerlink" title="1.kubernetes的认证"></a>1.kubernetes的认证</h4><p>kubernetes提供了多种认证方式，比如客户端证书、静态token、静态密码文件、ServiceAccountTokens等等。你可以同时使用一种或多种认证方式。只要通过任何一个都被认作是认证通过。下面我们就认识几个常见的认证方式。</p>
<ul>
<li><strong>客户端证书认证</strong> 客户端证书认证叫作TLS双向认证，也就是服务器客户端互相验证证书的正确性，在都正确的情况下协调通信加密方案。 为了使用这个方案，api-server需要用–client-ca-file选项来开启。</li>
<li><strong>引导Token</strong> 当我们有非常多的node节点时，手动为每个node节点配置TLS认证比较麻烦，这时就可以用到引导token的认证方式，前提是需要在api-server开启 experimental-bootstrap-token-auth 特性，客户端的token信息与预先定义的token匹配认证通过后，自动为node颁发证书。当然引导token是一种机制，可以用到各种场景中。</li>
<li><strong>Service Account Tokens 认证</strong> 有些情况下，我们希望在pod内部访问api-server，获取集群的信息，甚至对集群进行改动。针对这种情况，kubernetes提供了一种特殊的认证方式：Service Account。 Service Account 和 pod、service、deployment 一样是 kubernetes 集群中的一种资源，用户也可以创建自己的 Service Account。 ServiceAccount 主要包含了三个内容：namespace、Token 和 CA。namespace 指定了 pod 所在的 namespace，CA 用于验证 apiserver 的证书，token 用作身份验证。它们都通过 mount 的方式保存在 pod 的文件系统中。</li>
</ul>
<h4 id="2-kubernetes的授权"><a href="#2-kubernetes的授权" class="headerlink" title="2.kubernetes的授权"></a>2.kubernetes的授权</h4><p>在Kubernetes1.6版本中新增角色访问控制机制（Role-Based Access，RBAC）让集群管理员可以针对特定使用者或服务账号的角色，进行更精确的资源访问控制。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。 目前 Kubernetes 中有一系列的鉴权机制，因为Kubernetes社区的投入和偏好，相对于其它鉴权机制而言，RBAC是更好的选择。具体RBAC是如何体现在kubernetes系统中的我们会在后面的部署中逐步的深入了解。</p>
<h4 id="3-kubernetes的AdmissionControl"><a href="#3-kubernetes的AdmissionControl" class="headerlink" title="3.kubernetes的AdmissionControl"></a>3.kubernetes的AdmissionControl</h4><p>AdmissionControl - 准入控制本质上为一段准入代码，在对kubernetes api的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。这个准入代码在api-server中，而且必须被编译到二进制文件中才能被执行。 在对集群进行请求时，每个准入控制代码都按照一定顺序执行。如果有一个准入控制拒绝了此次请求，那么整个请求的结果将会立即返回，并提示用户相应的error信息。 常用组件（控制代码）如下：</p>
<ul>
<li>AlwaysAdmit：允许所有请求</li>
<li>AlwaysDeny：禁止所有请求，多用于测试环境</li>
<li>ServiceAccount：它将serviceAccounts实现了自动化，它会辅助serviceAccount做一些事情，比如如果pod没有serviceAccount属性，它会自动添加一个default，并确保pod的serviceAccount始终存在</li>
<li>LimitRanger：他会观察所有的请求，确保没有违反已经定义好的约束条件，这些条件定义在namespace中LimitRange对象中。如果在kubernetes中使用LimitRange对象，则必须使用这个插件。</li>
<li>NamespaceExists：它会观察所有的请求，如果请求尝试创建一个不存在的namespace，则这个请求被拒绝。</li>
</ul>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="1-停止原有kubernetes相关服务"><a href="#1-停止原有kubernetes相关服务" class="headerlink" title="1.停止原有kubernetes相关服务"></a>1.停止原有kubernetes相关服务</h4><p>开始之前我们要先把基础版本的集群停掉，包括service，deployments，pods以及运行的所有kubernetes组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#删除services</span><br><span class="line">$ kubectl delete services nginx-service</span><br><span class="line"></span><br><span class="line">#删除deployments</span><br><span class="line">$ kubectl delete deploy kubernetes-bootcamp</span><br><span class="line">$ kubectl delete deploy nginx-deployment</span><br><span class="line"></span><br><span class="line">#停掉worker节点的服务</span><br><span class="line">$ service kubelet stop &amp;&amp; rm -fr &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;*</span><br><span class="line">$ service kube-proxy stop &amp;&amp; rm -fr &#x2F;var&#x2F;lib&#x2F;kube-proxy&#x2F;*</span><br><span class="line">$ service kube-calico stop</span><br><span class="line"></span><br><span class="line">#停掉master节点的服务</span><br><span class="line">$ service kube-calico stop</span><br><span class="line">$ service kube-scheduler stop</span><br><span class="line">$ service kube-controller-manager stop</span><br><span class="line">$ service kube-apiserver stop</span><br><span class="line">$ service etcd stop &amp;&amp; rm -fr &#x2F;var&#x2F;lib&#x2F;etcd&#x2F;*</span><br></pre></td></tr></table></figure>

<h4 id="2-生成配置（所有节点）"><a href="#2-生成配置（所有节点）" class="headerlink" title="2.生成配置（所有节点）"></a>2.生成配置（所有节点）</h4><p>跟基础环境搭建一样，我们需要生成kubernetes-with-ca的所有相关配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;kubernetes-starter</span><br><span class="line">#按照配置文件的提示编辑好配置</span><br><span class="line">$ vi config.properties</span><br><span class="line">#生成配置</span><br><span class="line">$ .&#x2F;gen-config.sh with-ca</span><br></pre></td></tr></table></figure>

<h4 id="3-安装cfssl（所有节点）"><a href="#3-安装cfssl（所有节点）" class="headerlink" title="3.安装cfssl（所有节点）"></a>3.安装cfssl（所有节点）</h4><p>cfssl是非常好用的CA工具，我们用它来生成证书和秘钥文件<br>安装过程比较简单，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#下载</span><br><span class="line">$ wget -q --show-progress --https-only --timestamping \</span><br><span class="line">  https:&#x2F;&#x2F;pkg.cfssl.org&#x2F;R1.2&#x2F;cfssl_linux-amd64 \</span><br><span class="line">  https:&#x2F;&#x2F;pkg.cfssl.org&#x2F;R1.2&#x2F;cfssljson_linux-amd64</span><br><span class="line">#修改为可执行权限</span><br><span class="line">$ chmod +x cfssl_linux-amd64 cfssljson_linux-amd64</span><br><span class="line">#移动到bin目录</span><br><span class="line">$ mv cfssl_linux-amd64 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cfssl</span><br><span class="line">$ mv cfssljson_linux-amd64 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cfssljson</span><br><span class="line">#验证</span><br><span class="line">$ cfssl version</span><br></pre></td></tr></table></figure>

<h4 id="4-生成根证书（主节点）"><a href="#4-生成根证书（主节点）" class="headerlink" title="4.生成根证书（主节点）"></a>4.生成根证书（主节点）</h4><p>根证书是证书信任链的根，各个组件通讯的前提是有一份大家都信任的证书（根证书），每个人使用的证书都是由这个根证书签发的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#所有证书相关的东西都放在这</span><br><span class="line">$ mkdir -p &#x2F;etc&#x2F;kubernetes&#x2F;ca</span><br><span class="line">#准备生成证书的配置文件</span><br><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;ca&#x2F;ca-config.json &#x2F;etc&#x2F;kubernetes&#x2F;ca</span><br><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;ca&#x2F;ca-csr.json &#x2F;etc&#x2F;kubernetes&#x2F;ca</span><br><span class="line">#生成证书和秘钥</span><br><span class="line">$ cd &#x2F;etc&#x2F;kubernetes&#x2F;ca</span><br><span class="line">$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line">#生成完成后会有以下文件（我们最终想要的就是ca-key.pem和ca.pem，一个秘钥，一个证书）</span><br><span class="line">$ ls</span><br><span class="line">ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem</span><br></pre></td></tr></table></figure>

<h3 id="改造etcd"><a href="#改造etcd" class="headerlink" title="改造etcd"></a>改造etcd</h3><h4 id="1-准备证书"><a href="#1-准备证书" class="headerlink" title="1.准备证书"></a>1.准备证书</h4><p>etcd节点需要提供给其他服务访问，就要验证其他服务的身份，所以需要一个标识自己监听服务的server证书，当有多个etcd节点的时候也需要client证书与etcd集群其他节点交互，当然也可以client和server使用同一个证书因为它们本质上没有区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#etcd证书放在这</span><br><span class="line">$ mkdir -p &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;etcd</span><br><span class="line">#准备etcd证书配置</span><br><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;ca&#x2F;etcd&#x2F;etcd-csr.json &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;etcd&#x2F;</span><br><span class="line">$ cd &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;etcd&#x2F;</span><br><span class="line">#使用根证书(ca.pem)签发etcd证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca.pem \</span><br><span class="line">        -ca-key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca-key.pem \</span><br><span class="line">        -config&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca-config.json \</span><br><span class="line">        -profile&#x3D;kubernetes etcd-csr.json | cfssljson -bare etcd</span><br><span class="line">#跟之前类似生成三个文件etcd.csr是个中间证书请求文件，我们最终要的是etcd-key.pem和etcd.pem</span><br><span class="line">$ ls</span><br><span class="line">etcd.csr  etcd-csr.json  etcd-key.pem  etcd.pem</span><br></pre></td></tr></table></figure>

<h4 id="2-改造etcd服务"><a href="#2-改造etcd服务" class="headerlink" title="2.改造etcd服务"></a>2.改造etcd服务</h4><p>建议大家先比较一下增加认证的etcd配置与原有配置的区别，做到心中有数。 可以使用命令比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;kubernetes-starter&#x2F;</span><br><span class="line">$ vimdiff kubernetes-simple&#x2F;master-node&#x2F;etcd.service kubernetes-with-ca&#x2F;master-node&#x2F;etcd.service</span><br></pre></td></tr></table></figure>

<p><strong>更新etcd服务：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;master-node&#x2F;etcd.service &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service etcd start</span><br><span class="line">#验证etcd服务（endpoints自行替换）</span><br><span class="line">$ ETCDCTL_API&#x3D;3 etcdctl \</span><br><span class="line">  --endpoints&#x3D;https:&#x2F;&#x2F;192.168.1.102:2379  \</span><br><span class="line">  --cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca.pem \</span><br><span class="line">  --cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;etcd&#x2F;etcd.pem \</span><br><span class="line">  --key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;etcd&#x2F;etcd-key.pem \</span><br><span class="line">  endpoint health</span><br></pre></td></tr></table></figure>

<h3 id="改造api-server"><a href="#改造api-server" class="headerlink" title="改造api-server"></a>改造api-server</h3><h4 id="1-准备证书-1"><a href="#1-准备证书-1" class="headerlink" title="1.准备证书"></a>1.准备证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#api-server证书放在这，api-server是核心，文件夹叫kubernetes吧，如果想叫apiserver也可以，不过相关的地方都需要修改哦</span><br><span class="line">$ mkdir -p &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;kubernetes</span><br><span class="line">#准备apiserver证书配置</span><br><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;ca&#x2F;kubernetes&#x2F;kubernetes-csr.json &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;kubernetes&#x2F;</span><br><span class="line">$ cd &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;kubernetes&#x2F;</span><br><span class="line">#使用根证书(ca.pem)签发kubernetes证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca.pem \</span><br><span class="line">        -ca-key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca-key.pem \</span><br><span class="line">        -config&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca-config.json \</span><br><span class="line">        -profile&#x3D;kubernetes kubernetes-csr.json | cfssljson -bare kubernetes</span><br><span class="line">#跟之前类似生成三个文件kubernetes.csr是个中间证书请求文件，我们最终要的是kubernetes-key.pem和kubernetes.pem</span><br><span class="line">$ ls</span><br><span class="line">kubernetes.csr  kubernetes-csr.json  kubernetes-key.pem  kubernetes.pem</span><br></pre></td></tr></table></figure>

<h4 id="2-改造api-server服务"><a href="#2-改造api-server服务" class="headerlink" title="2.改造api-server服务"></a>2.改造api-server服务</h4><p><strong>查看diff</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;kubernetes-starter</span><br><span class="line">$ vimdiff kubernetes-simple&#x2F;master-node&#x2F;kube-apiserver.service kubernetes-with-ca&#x2F;master-node&#x2F;kube-apiserver.service</span><br></pre></td></tr></table></figure>

<p><strong>生成token认证文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#生成随机token</span><br><span class="line">$ head -c 16 &#x2F;dev&#x2F;urandom | od -An -t x | tr -d &#39; &#39;</span><br><span class="line">8afdf3c4eb7c74018452423c29433609</span><br><span class="line"></span><br><span class="line">#按照固定格式写入token.csv，注意替换token内容</span><br><span class="line">$ echo &quot;8afdf3c4eb7c74018452423c29433609,kubelet-bootstrap,10001,\&quot;system:kubelet-bootstrap\&quot;&quot; &gt; &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;kubernetes&#x2F;token.csv</span><br></pre></td></tr></table></figure>

<p><strong>更新api-server服务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;master-node&#x2F;kube-apiserver.service &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kube-apiserver start</span><br><span class="line"></span><br><span class="line">#检查日志</span><br><span class="line">$ journalctl -f -u kube-apiserver</span><br></pre></td></tr></table></figure>

<h3 id="改造controller-manager"><a href="#改造controller-manager" class="headerlink" title="改造controller-manager"></a>改造controller-manager</h3><p>controller-manager一般与api-server在同一台机器上，所以可以使用非安全端口与api-server通讯，不需要生成证书和私钥。</p>
<h4 id="1-改造controller-manager服务"><a href="#1-改造controller-manager服务" class="headerlink" title="1.改造controller-manager服务"></a>1.改造controller-manager服务</h4><p><strong>查看diff</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;kubernetes-starter&#x2F;</span><br><span class="line">$ vimdiff kubernetes-simple&#x2F;master-node&#x2F;kube-controller-manager.service kubernetes-with-ca&#x2F;master-node&#x2F;kube-controller-manager.service</span><br></pre></td></tr></table></figure>

<p><strong>更新controller-manager服务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;master-node&#x2F;kube-controller-manager.service &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kube-controller-manager start</span><br><span class="line"></span><br><span class="line">#检查日志</span><br><span class="line">$ journalctl -f -u kube-controller-manager</span><br></pre></td></tr></table></figure>

<h3 id="改造scheduler"><a href="#改造scheduler" class="headerlink" title="改造scheduler"></a>改造scheduler</h3><p>scheduler一般与apiserver在同一台机器上，所以可以使用非安全端口与apiserver通讯。不需要生成证书和私钥。</p>
<h4 id="1-改造scheduler服务"><a href="#1-改造scheduler服务" class="headerlink" title="1.改造scheduler服务"></a>1.改造scheduler服务</h4><p><strong>查看diff</strong> 比较会发现两个文件并没有区别，不需要改造</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;kubernetes-starter&#x2F;</span><br><span class="line">$ vimdiff kubernetes-simple&#x2F;master-node&#x2F;kube-scheduler.service kubernetes-with-ca&#x2F;master-node&#x2F;kube-scheduler.service</span><br></pre></td></tr></table></figure>

<p><strong>启动服务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ service kube-scheduler start</span><br><span class="line">#检查日志</span><br><span class="line">$ journalctl -f -u kube-scheduler</span><br></pre></td></tr></table></figure>

<h3 id="改造kubectl"><a href="#改造kubectl" class="headerlink" title="改造kubectl"></a>改造kubectl</h3><h4 id="1-准备证书-2"><a href="#1-准备证书-2" class="headerlink" title="1.准备证书"></a>1.准备证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#kubectl证书放在这，由于kubectl相当于系统管理员，我们使用admin命名</span><br><span class="line">$ mkdir -p &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;admin</span><br><span class="line">#准备admin证书配置 - kubectl只需客户端证书，因此证书请求中 hosts 字段可以为空</span><br><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;ca&#x2F;admin&#x2F;admin-csr.json &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;admin&#x2F;</span><br><span class="line">$ cd &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;admin&#x2F;</span><br><span class="line">#使用根证书(ca.pem)签发admin证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca.pem \</span><br><span class="line">        -ca-key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca-key.pem \</span><br><span class="line">        -config&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca-config.json \</span><br><span class="line">        -profile&#x3D;kubernetes admin-csr.json | cfssljson -bare admin</span><br><span class="line">#我们最终要的是admin-key.pem和admin.pem</span><br><span class="line">$ ls</span><br><span class="line">admin.csr  admin-csr.json  admin-key.pem  admin.pem</span><br></pre></td></tr></table></figure>

<h4 id="2-配置kubectl"><a href="#2-配置kubectl" class="headerlink" title="2.配置kubectl"></a>2.配置kubectl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#指定apiserver的地址和证书位置（ip自行修改）</span><br><span class="line">$ kubectl config set-cluster kubernetes \</span><br><span class="line">        --certificate-authority&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca.pem \</span><br><span class="line">        --embed-certs&#x3D;true \</span><br><span class="line">        --server&#x3D;https:&#x2F;&#x2F;192.168.1.102:6443</span><br><span class="line">#设置客户端认证参数，指定admin证书和秘钥</span><br><span class="line">$ kubectl config set-credentials admin \</span><br><span class="line">        --client-certificate&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;admin&#x2F;admin.pem \</span><br><span class="line">        --embed-certs&#x3D;true \</span><br><span class="line">        --client-key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;admin&#x2F;admin-key.pem</span><br><span class="line">#关联用户和集群</span><br><span class="line">$ kubectl config set-context kubernetes \</span><br><span class="line">        --cluster&#x3D;kubernetes --user&#x3D;admin</span><br><span class="line">#设置当前上下文</span><br><span class="line">$ kubectl config use-context kubernetes</span><br><span class="line"></span><br><span class="line">#设置结果就是一个配置文件，可以看看内容</span><br><span class="line">$ cat ~&#x2F;.kube&#x2F;config</span><br></pre></td></tr></table></figure>

<p><strong>验证master节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#可以使用刚配置好的kubectl查看一下组件状态</span><br><span class="line">$ kubectl get componentstatus</span><br><span class="line">NAME                 STATUS    MESSAGE              ERROR</span><br><span class="line">scheduler            Healthy   ok</span><br><span class="line">controller-manager   Healthy   ok</span><br><span class="line">etcd-0               Healthy   &#123;&quot;health&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改造calico-node"><a href="#改造calico-node" class="headerlink" title="改造calico-node"></a>改造calico-node</h3><h4 id="1-准备证书-3"><a href="#1-准备证书-3" class="headerlink" title="1.准备证书"></a>1.准备证书</h4><p>后续可以看到calico证书用在四个地方：</p>
<ul>
<li>calico/node 这个docker 容器运行时访问 etcd 使用证书</li>
<li>cni 配置文件中，cni 插件需要访问 etcd 使用证书</li>
<li>calicoctl 操作集群网络时访问 etcd 使用证书</li>
<li>calico/kube-controllers 同步集群网络策略时访问 etcd 使用证书</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#calico证书放在这</span><br><span class="line">$ mkdir -p &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;calico</span><br><span class="line">#准备calico证书配置 - calico只需客户端证书，因此证书请求中 hosts 字段可以为空</span><br><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;ca&#x2F;calico&#x2F;calico-csr.json &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;calico&#x2F;</span><br><span class="line">$ cd &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;calico&#x2F;</span><br><span class="line">#使用根证书(ca.pem)签发calico证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca.pem \</span><br><span class="line">        -ca-key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca-key.pem \</span><br><span class="line">        -config&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca-config.json \</span><br><span class="line">        -profile&#x3D;kubernetes calico-csr.json | cfssljson -bare calico</span><br><span class="line">#我们最终要的是calico-key.pem和calico.pem</span><br><span class="line">$ ls</span><br><span class="line">calico.csr  calico-csr.json  calico-key.pem  calico.pem</span><br></pre></td></tr></table></figure>

<h4 id="2-改造calico服务"><a href="#2-改造calico服务" class="headerlink" title="2.改造calico服务"></a>2.改造calico服务</h4><p><strong>查看diff</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;kubernetes-starter</span><br><span class="line">$ vimdiff kubernetes-simple&#x2F;all-node&#x2F;kube-calico.service kubernetes-with-ca&#x2F;all-node&#x2F;kube-calico.service</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过diff会发现，calico多了几个认证相关的文件：<br>/etc/kubernetes/ca/ca.pem<br>/etc/kubernetes/ca/calico/calico.pem<br>/etc/kubernetes/ca/calico/calico-key.pem<br>由于calico服务是所有节点都需要启动的，大家需要把这几个文件拷贝到每台服务器上</p>
</blockquote>
<p><strong>更新calico服务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;all-node&#x2F;kube-calico.service &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kube-calico start</span><br><span class="line"></span><br><span class="line">#验证calico（能看到其他节点的列表就对啦）</span><br><span class="line">$ calicoctl node status</span><br></pre></td></tr></table></figure>

<h3 id="改造kubelet"><a href="#改造kubelet" class="headerlink" title="改造kubelet"></a>改造kubelet</h3><p>我们这里让kubelet使用引导token的方式认证，所以认证方式跟之前的组件不同，它的证书不是手动生成，而是由工作节点TLS BootStrap 向api-server请求，由主节点的controller-manager 自动签发。</p>
<h4 id="1-创建角色绑定（主节点）"><a href="#1-创建角色绑定（主节点）" class="headerlink" title="1.创建角色绑定（主节点）"></a>1.创建角色绑定（主节点）</h4><p>引导token的方式要求客户端向api-server发起请求时告诉他你的用户名和token，并且这个用户是具有一个特定的角色：system:node-bootstrapper，所以需要先将 bootstrap token 文件中的 kubelet-bootstrap 用户赋予这个特定角色，然后 kubelet 才有权限发起创建认证请求。 <strong>在主节点执行下面命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#可以通过下面命令查询clusterrole列表</span><br><span class="line">$ kubectl -n kube-system get clusterrole</span><br><span class="line"></span><br><span class="line">#可以回顾一下token文件的内容</span><br><span class="line">$ cat &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;kubernetes&#x2F;token.csv</span><br><span class="line">8afdf3c4eb7c74018452423c29433609,kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;</span><br><span class="line"></span><br><span class="line">#创建角色绑定（将用户kubelet-bootstrap与角色system:node-bootstrapper绑定）</span><br><span class="line">$ kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line">         --clusterrole&#x3D;system:node-bootstrapper --user&#x3D;kubelet-bootstrap</span><br></pre></td></tr></table></figure>

<h4 id="2-创建bootstrap-kubeconfig（工作节点）"><a href="#2-创建bootstrap-kubeconfig（工作节点）" class="headerlink" title="2.创建bootstrap.kubeconfig（工作节点）"></a>2.创建bootstrap.kubeconfig（工作节点）</h4><p>这个配置是用来完成bootstrap token认证的，保存了像用户，token等重要的认证信息，这个文件可以借助kubectl命令生成：（也可以自己写配置）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#设置集群参数(注意替换ip)</span><br><span class="line">$ kubectl config set-cluster kubernetes \</span><br><span class="line">        --certificate-authority&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca.pem \</span><br><span class="line">        --embed-certs&#x3D;true \</span><br><span class="line">        --server&#x3D;https:&#x2F;&#x2F;192.168.1.102:6443 \</span><br><span class="line">        --kubeconfig&#x3D;bootstrap.kubeconfig</span><br><span class="line">#设置客户端认证参数(注意替换token)</span><br><span class="line">$ kubectl config set-credentials kubelet-bootstrap \</span><br><span class="line">        --token&#x3D;8afdf3c4eb7c74018452423c29433609 \</span><br><span class="line">        --kubeconfig&#x3D;bootstrap.kubeconfig</span><br><span class="line">#设置上下文</span><br><span class="line">$ kubectl config set-context default \</span><br><span class="line">        --cluster&#x3D;kubernetes \</span><br><span class="line">        --user&#x3D;kubelet-bootstrap \</span><br><span class="line">        --kubeconfig&#x3D;bootstrap.kubeconfig</span><br><span class="line">#选择上下文</span><br><span class="line">$ kubectl config use-context default --kubeconfig&#x3D;bootstrap.kubeconfig</span><br><span class="line">#将刚生成的文件移动到合适的位置</span><br><span class="line">$ mv bootstrap.kubeconfig &#x2F;etc&#x2F;kubernetes&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="3-准备cni配置"><a href="#3-准备cni配置" class="headerlink" title="3.准备cni配置"></a>3.准备cni配置</h4><p><strong>查看diff</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;kubernetes-starter</span><br><span class="line">$ vimdiff kubernetes-simple&#x2F;worker-node&#x2F;10-calico.conf kubernetes-with-ca&#x2F;worker-node&#x2F;10-calico.conf</span><br></pre></td></tr></table></figure>

<p><strong>copy配置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;worker-node&#x2F;10-calico.conf &#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="4-改造kubelet服务"><a href="#4-改造kubelet服务" class="headerlink" title="4.改造kubelet服务"></a>4.改造kubelet服务</h4><p><strong>查看diff</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;kubernetes-starter</span><br><span class="line">$ vimdiff kubernetes-simple&#x2F;worker-node&#x2F;kubelet.service kubernetes-with-ca&#x2F;worker-node&#x2F;kubelet.service</span><br></pre></td></tr></table></figure>

<p><strong>更新服务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;worker-node&#x2F;kubelet.service &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kubelet start</span><br><span class="line"></span><br><span class="line">#启动kubelet之后到master节点允许worker加入(批准worker的tls证书请求)</span><br><span class="line">#--------*在主节点执行*---------</span><br><span class="line">$ kubectl get csr|grep &#39;Pending&#39; | awk &#39;&#123;print $1&#125;&#39;| xargs kubectl certificate approve</span><br><span class="line">#-----------------------------</span><br><span class="line"></span><br><span class="line">#检查日志</span><br><span class="line">$ journalctl -f -u kubelet</span><br></pre></td></tr></table></figure>

<h3 id="改造kube-proxy"><a href="#改造kube-proxy" class="headerlink" title="改造kube-proxy"></a>改造kube-proxy</h3><h4 id="1-准备证书-4"><a href="#1-准备证书-4" class="headerlink" title="1.准备证书"></a>1.准备证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#proxy证书放在这</span><br><span class="line">$ mkdir -p &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;kube-proxy</span><br><span class="line"></span><br><span class="line">#准备proxy证书配置 - proxy只需客户端证书，因此证书请求中 hosts 字段可以为空。</span><br><span class="line">#CN 指定该证书的 User 为 system:kube-proxy，预定义的 ClusterRoleBinding system:node-proxy 将User system:kube-proxy 与 Role system:node-proxier 绑定，授予了调用 kube-api-server proxy的相关 API 的权限</span><br><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;ca&#x2F;kube-proxy&#x2F;kube-proxy-csr.json &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;kube-proxy&#x2F;</span><br><span class="line">$ cd &#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;kube-proxy&#x2F;</span><br><span class="line"></span><br><span class="line">#使用根证书(ca.pem)签发calico证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca.pem \</span><br><span class="line">        -ca-key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca-key.pem \</span><br><span class="line">        -config&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca-config.json \</span><br><span class="line">        -profile&#x3D;kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line">#我们最终要的是kube-proxy-key.pem和kube-proxy.pem</span><br><span class="line">$ ls</span><br><span class="line">kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem</span><br></pre></td></tr></table></figure>

<h4 id="2-生成kube-proxy-kubeconfig配置"><a href="#2-生成kube-proxy-kubeconfig配置" class="headerlink" title="2.生成kube-proxy.kubeconfig配置"></a>2.生成kube-proxy.kubeconfig配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#设置集群参数（注意替换ip）</span><br><span class="line">$ kubectl config set-cluster kubernetes \</span><br><span class="line">        --certificate-authority&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;ca.pem \</span><br><span class="line">        --embed-certs&#x3D;true \</span><br><span class="line">        --server&#x3D;https:&#x2F;&#x2F;192.168.1.102:6443 \</span><br><span class="line">        --kubeconfig&#x3D;kube-proxy.kubeconfig</span><br><span class="line">#置客户端认证参数</span><br><span class="line">$ kubectl config set-credentials kube-proxy \</span><br><span class="line">        --client-certificate&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;kube-proxy&#x2F;kube-proxy.pem \</span><br><span class="line">        --client-key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ca&#x2F;kube-proxy&#x2F;kube-proxy-key.pem \</span><br><span class="line">        --embed-certs&#x3D;true \</span><br><span class="line">        --kubeconfig&#x3D;kube-proxy.kubeconfig</span><br><span class="line">#设置上下文参数</span><br><span class="line">$ kubectl config set-context default \</span><br><span class="line">        --cluster&#x3D;kubernetes \</span><br><span class="line">        --user&#x3D;kube-proxy \</span><br><span class="line">        --kubeconfig&#x3D;kube-proxy.kubeconfig</span><br><span class="line">#选择上下文</span><br><span class="line">$ kubectl config use-context default --kubeconfig&#x3D;kube-proxy.kubeconfig</span><br><span class="line">#移动到合适位置</span><br><span class="line">$ mv kube-proxy.kubeconfig &#x2F;etc&#x2F;kubernetes&#x2F;kube-proxy.kubeconfig</span><br></pre></td></tr></table></figure>

<h4 id="3-改造kube-proxy服务"><a href="#3-改造kube-proxy服务" class="headerlink" title="3.改造kube-proxy服务"></a>3.改造kube-proxy服务</h4><p><strong>查看diff</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;kubernetes-starter</span><br><span class="line">$ vimdiff kubernetes-simple&#x2F;worker-node&#x2F;kube-proxy.service kubernetes-with-ca&#x2F;worker-node&#x2F;kube-proxy.service</span><br></pre></td></tr></table></figure>

<blockquote>
<p>经过diff你应该发现kube-proxy.service没有变化</p>
</blockquote>
<p><strong>启动服务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#如果之前的配置没有了，可以重新复制一份过去</span><br><span class="line">$ cp ~&#x2F;kubernetes-starter&#x2F;target&#x2F;worker-node&#x2F;kube-proxy.service &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">#安装依赖软件</span><br><span class="line">$ apt install conntrack</span><br><span class="line"></span><br><span class="line">#启动服务</span><br><span class="line">$ service kube-proxy start</span><br><span class="line">#查看日志</span><br><span class="line">$ journalctl -f -u kube-proxy</span><br></pre></td></tr></table></figure>

<h3 id="改造kube-dns"><a href="#改造kube-dns" class="headerlink" title="改造kube-dns"></a>改造kube-dns</h3><p>kube-dns有些特别，因为它本身是运行在kubernetes集群中，以kubernetes应用的形式运行。所以它的认证授权方式跟之前的组件都不一样。它需要用到service account认证和RBAC授权。<br><strong>service account认证：</strong><br>每个service account都会自动生成自己的secret，用于包含一个ca，token和secret，用于跟api-server认证<br><strong>RBAC授权：</strong><br>权限、角色和角色绑定都是kubernetes自动创建好的。我们只需要创建一个叫做kube-dns的 ServiceAccount即可，官方现有的配置已经把它包含进去了。</p>
<h4 id="1-准备配置文件"><a href="#1-准备配置文件" class="headerlink" title="1.准备配置文件"></a>1.准备配置文件</h4><p>我们在官方的基础上添加的变量，生成适合我们集群的配置。直接copy就可以啦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;kubernetes-starter</span><br><span class="line">$ vimdiff kubernetes-simple&#x2F;services&#x2F;kube-dns.yaml kubernetes-with-ca&#x2F;services&#x2F;kube-dns.yaml</span><br></pre></td></tr></table></figure>

<blockquote>
<p>大家可以看到diff只有一处，新的配置没有设定api-server。不访问api-server，它是怎么知道每个服务的cluster ip和pod的endpoints的呢？这就是因为kubernetes在启动每个服务service的时候会以环境变量的方式把所有服务的ip，端口等信息注入进来。</p>
</blockquote>
<h4 id="2-创建kube-dns"><a href="#2-创建kube-dns" class="headerlink" title="2.创建kube-dns"></a>2.创建kube-dns</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f ~&#x2F;kubernetes-starter&#x2F;target&#x2F;services&#x2F;kube-dns.yaml</span><br><span class="line">#看看启动是否成功</span><br><span class="line">$ kubectl -n kube-system get pods</span><br></pre></td></tr></table></figure>

<h1 id="kubernetes集群部署微服务"><a href="#kubernetes集群部署微服务" class="headerlink" title="kubernetes集群部署微服务"></a>kubernetes集群部署微服务</h1><h2 id="1-微服务部署方案-思路整理"><a href="#1-微服务部署方案-思路整理" class="headerlink" title="1. 微服务部署方案 - 思路整理"></a>1. 微服务部署方案 - 思路整理</h2><h5 id="我们有如下微服务："><a href="#我们有如下微服务：" class="headerlink" title="我们有如下微服务："></a>我们有如下微服务：</h5><ul>
<li>消息服务：message-service</li>
<li>课程dubbo服务：course-dubbo-service</li>
<li>课程web服务：course-edge-service</li>
<li>用户thrift服务：user-thrift-service</li>
<li>用户web服务：user-edge-service</li>
<li>API网关：api-gateway</li>
</ul>
<h5 id="把它们放到kubernetes集群运行我们要考虑什么问题？"><a href="#把它们放到kubernetes集群运行我们要考虑什么问题？" class="headerlink" title="把它们放到kubernetes集群运行我们要考虑什么问题？"></a>把它们放到kubernetes集群运行我们要考虑什么问题？</h5><ul>
<li>哪些服务适合单独成为一个pod？哪些服务适合在一个pod中？</li>
<li>在一个pod里面的服务如何彼此访问？他们的服务如何对外提供服务？</li>
<li>单独的pod如何对外提供服务？</li>
<li>哪个服务作为整个服务的入口，入口服务如何对外提供服务？</li>
</ul>
<h2 id="2-搞定配置"><a href="#2-搞定配置" class="headerlink" title="2. 搞定配置"></a>2. 搞定配置</h2><p>配置的模板已经为大家准备好了，但是还需要大家做一下处理才能使用哦，参考下面脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;kubernetes-starter&#x2F;service-config&#x2F;</span><br><span class="line">$ ls</span><br><span class="line">api-gateway.yaml     message-service.yaml</span><br><span class="line">course-service.yaml  user-service.yaml</span><br><span class="line">#替换变量 - (hub.mooc.com:8080是我的环境的镜像仓库地址，大家修改为各自的仓库)</span><br><span class="line">$ sed -i &#39;s&#x2F;&#123;&#123;HUB&#125;&#125;&#x2F;hub.mooc.com:8080&#x2F;g&#39; *</span><br></pre></td></tr></table></figure>

<h2 id="3-部署服务"><a href="#3-部署服务" class="headerlink" title="3. 部署服务"></a>3. 部署服务</h2><h5 id="部署前准备："><a href="#部署前准备：" class="headerlink" title="部署前准备："></a>部署前准备：</h5><ul>
<li><strong>要过一遍我们现有的代码配置，看看是否有需要修改的，修改后需要新生成镜像</strong></li>
<li><strong>要启动好微服务依赖的服务，像zookeeper，mysql，registry等</strong></li>
</ul>

          
            <br>
            
  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=https://www.bcoder.top/2019/01/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89/>https://www.bcoder.top/2019/01/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-01-21T18:44:04+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2020-01-21 18:44:04</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>微服务</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/k8s/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>k8s</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/CI-CD/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>CI/CD</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.bcoder.top/2019/01/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89/&title=微服务容器化实践（二） - zln's blog&summary=Kubernetes基础Kubernetes介绍首先，Kubernetes是一个全新的基于容器技术的分布式架构领先方案。Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能，利用Kubernetes能方便地管理跨机器运行容器化的应用，其主要功能如下：

使用Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。
以集群的方式运行、管理跨机器的容器。
解决Docker跨机器容器之间的通讯问题。
Kubernetes的自我修复机制使得容器集群总是运行在用户期望的状态。
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://www.bcoder.top/2019/01/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89/&title=微服务容器化实践（二） - zln's blog&summary=Kubernetes基础Kubernetes介绍首先，Kubernetes是一个全新的基于容器技术的分布式架构领先方案。Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能，利用Kubernetes能方便地管理跨机器运行容器化的应用，其主要功能如下：

使用Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。
以集群的方式运行、管理跨机器的容器。
解决Docker跨机器容器之间的通讯问题。
Kubernetes的自我修复机制使得容器集群总是运行在用户期望的状态。
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://www.bcoder.top/2019/01/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89/&title=微服务容器化实践（二） - zln's blog&summary=Kubernetes基础Kubernetes介绍首先，Kubernetes是一个全新的基于容器技术的分布式架构领先方案。Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能，利用Kubernetes能方便地管理跨机器运行容器化的应用，其主要功能如下：

使用Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。
以集群的方式运行、管理跨机器的容器。
解决Docker跨机器容器之间的通讯问题。
Kubernetes的自我修复机制使得容器集群总是运行在用户期望的状态。
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2019/01/22/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94KMP/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>基础算法学习（三）——KMP</p>
                <p class='content'>KMP算法求解的问题给定两个字符串str和match，长度分别为N和M。实现一个算法，如果字符串str中含有子串match，则返回match在str中的开始位置。不含有则返回-1.
例如：
st...</p>
              </a>
            
            
              <a class='next' href='/2019/01/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/'>
                <p class='title'>微服务容器化实践（一）<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>Docker 基础Docker介绍Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。
Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-spinner fa-spin fa-fw"></i>
          </div>
        </section>
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: '微服务容器化实践（二）',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes基础"><span class="toc-number">1.</span> <span class="toc-text">Kubernetes基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes介绍"><span class="toc-number">1.1.</span> <span class="toc-text">Kubernetes介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用Kubernetes？"><span class="toc-number">1.2.</span> <span class="toc-text">为什么使用Kubernetes？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes的核心概念"><span class="toc-number">1.3.</span> <span class="toc-text">Kubernetes的核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes的体系结构"><span class="toc-number">1.4.</span> <span class="toc-text">Kubernetes的体系结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes集群搭建（环境准备）"><span class="toc-number">2.</span> <span class="toc-text">Kubernetes集群搭建（环境准备）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#环境说明"><span class="toc-number">2.1.</span> <span class="toc-text">环境说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装docker（所有节点）"><span class="toc-number">2.2.</span> <span class="toc-text">安装docker（所有节点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-卸载旧版本-如果有的话"><span class="toc-number">2.2.1.</span> <span class="toc-text">1 卸载旧版本(如果有的话)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-更新apt-get源"><span class="toc-number">2.2.2.</span> <span class="toc-text">2 更新apt-get源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-安装apt的https支持包并添加gpg秘钥"><span class="toc-number">2.2.3.</span> <span class="toc-text">3 安装apt的https支持包并添加gpg秘钥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-安装docker-ce"><span class="toc-number">2.2.4.</span> <span class="toc-text">4 安装docker-ce</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统设置（所有节点）"><span class="toc-number">2.3.</span> <span class="toc-text">系统设置（所有节点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-关闭、禁用防火墙-让所有机器之间都可以通过任意端口建立连接"><span class="toc-number">2.3.1.</span> <span class="toc-text">1 关闭、禁用防火墙(让所有机器之间都可以通过任意端口建立连接)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-设置系统参数-允许路由转发，不对bridge的数据进行处理"><span class="toc-number">2.3.2.</span> <span class="toc-text">2 设置系统参数 - 允许路由转发，不对bridge的数据进行处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-配置host文件"><span class="toc-number">2.3.3.</span> <span class="toc-text">3 配置host文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#准备二进制文件（所有节点）"><span class="toc-number">2.4.</span> <span class="toc-text">准备二进制文件（所有节点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#准备配置文件（所有节点）"><span class="toc-number">2.5.</span> <span class="toc-text">准备配置文件（所有节点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-下载配置文件"><span class="toc-number">2.5.1.</span> <span class="toc-text">1 下载配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-文件说明"><span class="toc-number">2.5.2.</span> <span class="toc-text">2 文件说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-生成配置"><span class="toc-number">2.5.3.</span> <span class="toc-text">3 生成配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes集群搭建（基础功能安装）"><span class="toc-number">3.</span> <span class="toc-text">Kubernetes集群搭建（基础功能安装）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#部署ETCD（主节点）"><span class="toc-number">3.1.</span> <span class="toc-text">部署ETCD（主节点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介"><span class="toc-number">3.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#部署"><span class="toc-number">3.1.2.</span> <span class="toc-text">部署</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#部署APIServer（主节点）"><span class="toc-number">3.2.</span> <span class="toc-text">部署APIServer（主节点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-简介"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-部署"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.部署</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#部署ControllerManager（主节点）"><span class="toc-number">3.3.</span> <span class="toc-text">部署ControllerManager（主节点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#部署-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">部署</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#部署Scheduler（主节点）"><span class="toc-number">3.4.</span> <span class="toc-text">部署Scheduler（主节点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#部署-2"><span class="toc-number">3.4.2.</span> <span class="toc-text">部署</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#部署CalicoNode（所有节点）"><span class="toc-number">3.5.</span> <span class="toc-text">部署CalicoNode（所有节点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介-3"><span class="toc-number">3.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#部署-3"><span class="toc-number">3.5.2.</span> <span class="toc-text">部署</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#验证"><span class="toc-number">3.5.3.</span> <span class="toc-text">验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置kubectl命令（任意节点）"><span class="toc-number">3.6.</span> <span class="toc-text">配置kubectl命令（任意节点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介-4"><span class="toc-number">3.6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化"><span class="toc-number">3.6.2.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置kubelet（工作节点）"><span class="toc-number">3.7.</span> <span class="toc-text">配置kubelet（工作节点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介-5"><span class="toc-number">3.7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#部署-4"><span class="toc-number">3.7.2.</span> <span class="toc-text">部署</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础集群测试"><span class="toc-number">4.</span> <span class="toc-text">基础集群测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes集群搭建（完整）"><span class="toc-number">5.</span> <span class="toc-text">Kubernetes集群搭建（完整）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解认证授权"><span class="toc-number">5.1.</span> <span class="toc-text">理解认证授权</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-为什么要认证"><span class="toc-number">5.1.1.</span> <span class="toc-text">1.为什么要认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-概念梳理"><span class="toc-number">5.1.2.</span> <span class="toc-text">2.概念梳理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-什么是授权"><span class="toc-number">5.1.3.</span> <span class="toc-text">3.什么是授权</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kubernetes的认证授权"><span class="toc-number">5.2.</span> <span class="toc-text">kubernetes的认证授权</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-kubernetes的认证"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.kubernetes的认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-kubernetes的授权"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.kubernetes的授权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-kubernetes的AdmissionControl"><span class="toc-number">5.2.3.</span> <span class="toc-text">3.kubernetes的AdmissionControl</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#环境准备"><span class="toc-number">5.3.</span> <span class="toc-text">环境准备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-停止原有kubernetes相关服务"><span class="toc-number">5.3.1.</span> <span class="toc-text">1.停止原有kubernetes相关服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-生成配置（所有节点）"><span class="toc-number">5.3.2.</span> <span class="toc-text">2.生成配置（所有节点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-安装cfssl（所有节点）"><span class="toc-number">5.3.3.</span> <span class="toc-text">3.安装cfssl（所有节点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-生成根证书（主节点）"><span class="toc-number">5.3.4.</span> <span class="toc-text">4.生成根证书（主节点）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改造etcd"><span class="toc-number">5.4.</span> <span class="toc-text">改造etcd</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-准备证书"><span class="toc-number">5.4.1.</span> <span class="toc-text">1.准备证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-改造etcd服务"><span class="toc-number">5.4.2.</span> <span class="toc-text">2.改造etcd服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改造api-server"><span class="toc-number">5.5.</span> <span class="toc-text">改造api-server</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-准备证书-1"><span class="toc-number">5.5.1.</span> <span class="toc-text">1.准备证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-改造api-server服务"><span class="toc-number">5.5.2.</span> <span class="toc-text">2.改造api-server服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改造controller-manager"><span class="toc-number">5.6.</span> <span class="toc-text">改造controller-manager</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-改造controller-manager服务"><span class="toc-number">5.6.1.</span> <span class="toc-text">1.改造controller-manager服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改造scheduler"><span class="toc-number">5.7.</span> <span class="toc-text">改造scheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-改造scheduler服务"><span class="toc-number">5.7.1.</span> <span class="toc-text">1.改造scheduler服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改造kubectl"><span class="toc-number">5.8.</span> <span class="toc-text">改造kubectl</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-准备证书-2"><span class="toc-number">5.8.1.</span> <span class="toc-text">1.准备证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-配置kubectl"><span class="toc-number">5.8.2.</span> <span class="toc-text">2.配置kubectl</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改造calico-node"><span class="toc-number">5.9.</span> <span class="toc-text">改造calico-node</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-准备证书-3"><span class="toc-number">5.9.1.</span> <span class="toc-text">1.准备证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-改造calico服务"><span class="toc-number">5.9.2.</span> <span class="toc-text">2.改造calico服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改造kubelet"><span class="toc-number">5.10.</span> <span class="toc-text">改造kubelet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-创建角色绑定（主节点）"><span class="toc-number">5.10.1.</span> <span class="toc-text">1.创建角色绑定（主节点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-创建bootstrap-kubeconfig（工作节点）"><span class="toc-number">5.10.2.</span> <span class="toc-text">2.创建bootstrap.kubeconfig（工作节点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-准备cni配置"><span class="toc-number">5.10.3.</span> <span class="toc-text">3.准备cni配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-改造kubelet服务"><span class="toc-number">5.10.4.</span> <span class="toc-text">4.改造kubelet服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改造kube-proxy"><span class="toc-number">5.11.</span> <span class="toc-text">改造kube-proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-准备证书-4"><span class="toc-number">5.11.1.</span> <span class="toc-text">1.准备证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-生成kube-proxy-kubeconfig配置"><span class="toc-number">5.11.2.</span> <span class="toc-text">2.生成kube-proxy.kubeconfig配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-改造kube-proxy服务"><span class="toc-number">5.11.3.</span> <span class="toc-text">3.改造kube-proxy服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改造kube-dns"><span class="toc-number">5.12.</span> <span class="toc-text">改造kube-dns</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-准备配置文件"><span class="toc-number">5.12.1.</span> <span class="toc-text">1.准备配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-创建kube-dns"><span class="toc-number">5.12.2.</span> <span class="toc-text">2.创建kube-dns</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-微服务部署方案-思路整理"><span class="toc-number">6.</span> <span class="toc-text">1. 微服务部署方案 - 思路整理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#我们有如下微服务："><span class="toc-number">6.0.0.1.</span> <span class="toc-text">我们有如下微服务：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#把它们放到kubernetes集群运行我们要考虑什么问题？"><span class="toc-number">6.0.0.2.</span> <span class="toc-text">把它们放到kubernetes集群运行我们要考虑什么问题？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-搞定配置"><span class="toc-number">7.</span> <span class="toc-text">2. 搞定配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-部署服务"><span class="toc-number">8.</span> <span class="toc-text">3. 部署服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#部署前准备："><span class="toc-number">8.0.0.1.</span> <span class="toc-text">部署前准备：</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="https://www.bcoder.top"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/zlnnjit"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=430673592"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        Use
        <a href="https://bcoder.top/" target="_blank" class="codename">周陆宁</a>
        as theme
        
          , 
          total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://bocder.top" target="_blank" rel="noopener">Copyright © 2016-2020 zlnnjit</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script>

  








  
    
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.2.0/js/valine.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var guest_info = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var notify = 'true' == true;
  var verify = 'true' == true;
  var valine = new Valine();
  valine.init({
    el: '#valine_container',
    notify: notify,
    verify: verify,
    guest_info: guest_info,
    
    appId: "M3YhrSNLSJTxyKwa8hGSGbH7-gzGzoHsz",
    appKey: "RwjMsAULtRweeA4GtaqJGPVu",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'mp',
    lang:'zh-cn',
    visitor: 'false',
    highlight:'true'
  })
  </script>



  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>



<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->

  <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>






  <script>setLoadingBarProgress(100);</script>
</body>
</html>
